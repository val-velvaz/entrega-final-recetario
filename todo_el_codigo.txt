===== C:\Universidad\estructuras-de-datos\include\datastructures\managers\ManejadorIngredientes.hpp =====
#pragma once

// DefiniciÃ³n mÃ­nima de la clase para que compile
class ManejadorIngredientes {
public:
    // Constructor
    ManejadorIngredientes();
    
    // Destructor
    ~ManejadorIngredientes();
};


===== C:\Universidad\estructuras-de-datos\include\datastructures\managers\ManejadorRecetas.hpp =====
#pragma once

#include "entities/Receta.hpp"
#include "datastructures/templates/ListaDoblementeLigada.hpp"
#include <string>
#include <vector>
#include <stdexcept>

class ManejadorRecetas {
private:
    ListaDoblementeLigada<Receta> recetasAlmacenadas;

    int encontrarIndiceRecetaPorNombre(const std::string& nombreBuscado) const;
    
    int particion(ListaDoblementeLigada<Receta>& lista, int izquierda, int derecha, int (*comparador)(const Receta&, const Receta&));
    
    void quickSortRecursivo(
        ListaDoblementeLigada<Receta>& lista,
        int izquierda,
        int derecha,
        int (*comparador)(const Receta&, const Receta&)
    );

public:
    ManejadorRecetas();
    ~ManejadorRecetas();

    // CRUD Básico
    void agregarRecetaNueva(const Receta& recetaAinsertar);
    Receta& obtenerRecetaPorNombre(const std::string& nombreBuscado);
    const Receta& obtenerRecetaPorNombreConstante(const std::string& nombreBuscado) const;
    void eliminarRecetaPorNombre(const std::string& nombreAeliminar);
    void eliminarTodasLasRecetas();
    bool verificarSiRecetaExiste(const std::string& nombreReceta) const;

    int obtenerCantidadRecetas() const { return recetasAlmacenadas.obtenerCantidadElementos(); }
    Receta& obtenerRecetaEnPosicion(int indice) { return recetasAlmacenadas.obtenerEnPosicion(indice); }
    const Receta& obtenerRecetaEnPosicion(int indice) const { return recetasAlmacenadas.obtenerEnPosicion(indice); }

    // ORDENAMIENTO
    void ordenarRecetasPorNombre();
    void ordenarRecetasPorTiempoPreparacion();
    void ordenarRecetasPorCategoria();
    void ordenarRecetasPorAutor();

    // BÚSQUEDA
    Receta* buscarRecetaBinariaPorNombre(const std::string& nombreBuscado);

    // Persistencia
    bool archivoEsValido(const std::string& rutaArchivo); // ?? NUEVO
    void guardarRecetasAarchivo(const std::string& rutaArchivo);
    void cargarRecetasDesdeArchivo(const std::string& rutaArchivo);
    std::string obtenerEstadisticasRecetario() const;
};


===== C:\Universidad\estructuras-de-datos\include\datastructures\templates\ArbolBinarioBusqueda.hpp =====
#pragma once
#include <iostream>
#include <functional>

template <typename T>
struct NodoArbol {
    T dato;
    NodoArbol* izquierda;
    NodoArbol* derecha;

    NodoArbol(const T& valor) : dato(valor), izquierda(nullptr), derecha(nullptr) {}
};

template <typename T>
class ArbolBinarioBusqueda {
private:
    NodoArbol<T>* raiz;

    void insertarRecursivo(NodoArbol<T>*& nodo, const T& valor, std::function<int(const T&, const T&)> comparador) {
        if (nodo == nullptr) {
            nodo = new NodoArbol<T>(valor);
        } else {
            int comparacion = comparador(valor, nodo->dato);
            if (comparacion < 0) {
                insertarRecursivo(nodo->izquierda, valor, comparador);
            } else if (comparacion > 0) {
                insertarRecursivo(nodo->derecha, valor, comparador);
            }
            // Si es igual, decidimos no duplicar o manejarlo segÃºn lÃ³gica
        }
    }

    T* buscarRecursivo(NodoArbol<T>* nodo, const T& valorBusqueda, std::function<int(const T&, const T&)> comparador) const {
        if (nodo == nullptr) {
            return nullptr;
        }
        int comparacion = comparador(valorBusqueda, nodo->dato);
        if (comparacion == 0) {
            return &(nodo->dato);
        } else if (comparacion < 0) {
            return buscarRecursivo(nodo->izquierda, valorBusqueda, comparador);
        } else {
            return buscarRecursivo(nodo->derecha, valorBusqueda, comparador);
        }
    }

    void destruirRecursivo(NodoArbol<T>* nodo) {
        if (nodo) {
            destruirRecursivo(nodo->izquierda);
            destruirRecursivo(nodo->derecha);
            delete nodo;
        }
    }

public:
    ArbolBinarioBusqueda() : raiz(nullptr) {}

    ~ArbolBinarioBusqueda() {
        destruirRecursivo(raiz);
    }

    void insertar(const T& valor, std::function<int(const T&, const T&)> comparador) {
        insertarRecursivo(raiz, valor, comparador);
    }

    T* buscar(const T& valorBusqueda, std::function<int(const T&, const T&)> comparador) const {
        return buscarRecursivo(raiz, valorBusqueda, comparador);
    }

    bool estaVacio() const {
        return raiz == nullptr;
    }
    
    void limpiar() {
        destruirRecursivo(raiz);
        raiz = nullptr;
    }
};


===== C:\Universidad\estructuras-de-datos\include\datastructures\templates\ColaDinamica.hpp =====
#pragma once

#include "ListaSimplementeLigada.hpp"
#include <stdexcept>

template <typename TipoDato>
class ColaDinamica {
private:
    ListaSimplementeLigada<TipoDato> listaContenedora;

public:
    ColaDinamica() = default;
    
    void encolar(const TipoDato& elemento) {
        listaContenedora.agregarAlFinal(elemento);
    }
    
    void desencolar() {
        if (estaVacia()) {
            throw std::underflow_error("Cola vacÃ­a");
        }
        listaContenedora.eliminarDelInicio();
    }
    
    TipoDato& frente() {
        if (estaVacia()) {
            throw std::underflow_error("Cola vacÃ­a");
        }
        return listaContenedora.obtenerEnPosicion(0);
    }
    
    bool estaVacia() const {
        return listaContenedora.estaVacia();
    }
    
    int obtenerTamano() const {
        return listaContenedora.obtenerCantidadElementos();
    }
    
    void limpiar() {
        listaContenedora.limpiarLista();
    }
};


===== C:\Universidad\estructuras-de-datos\include\datastructures\templates\ListaCircularDoble.hpp =====
#pragma once

#include "NodoCircularDoble.hpp"
#include <stdexcept>

template <typename TipoDato>
class ListaCircularDoble {
private:
    NodoCircularDoble<TipoDato>* cabeza;
    int cantidadElementos;

public:
    ListaCircularDoble() : cabeza(nullptr), cantidadElementos(0) {}
    
    ~ListaCircularDoble() {
        limpiar();
    }
    
    void agregarAlFinal(const TipoDato& dato) {
        NodoCircularDoble<TipoDato>* nuevo = new NodoCircularDoble<TipoDato>(dato);
        
        if (!cabeza) {
            cabeza = nuevo;
            cabeza->punteroSiguienteNodo = cabeza;
            cabeza->punteroAnteriorNodo = cabeza;
        } else {
            NodoCircularDoble<TipoDato>* ultimo = cabeza->punteroAnteriorNodo;
            
            ultimo->punteroSiguienteNodo = nuevo;
            nuevo->punteroAnteriorNodo = ultimo;
            nuevo->punteroSiguienteNodo = cabeza;
            cabeza->punteroAnteriorNodo = nuevo;
        }
        cantidadElementos++;
    }
    
    void eliminarDelFrente() {
        if (estaVacia()) throw std::underflow_error("Lista vacÃ­a");
        
        if (cantidadElementos == 1) {
            delete cabeza;
            cabeza = nullptr;
        } else {
            NodoCircularDoble<TipoDato>* viejaCabeza = cabeza;
            NodoCircularDoble<TipoDato>* ultimo = cabeza->punteroAnteriorNodo;
            
            cabeza = cabeza->punteroSiguienteNodo;
            cabeza->punteroAnteriorNodo = ultimo;
            ultimo->punteroSiguienteNodo = cabeza;
            
            delete viejaCabeza;
        }
        cantidadElementos--;
    }
    
    bool estaVacia() const { return cantidadElementos == 0; }
    int obtenerTamano() const { return cantidadElementos; }
    
    void limpiar() {
        while (!estaVacia()) {
            eliminarDelFrente();
        }
    }
};


===== C:\Universidad\estructuras-de-datos\include\datastructures\templates\ListaDoblementeLigada.hpp =====
#pragma once

#include "NodoDoblementeLigado.hpp"
#include <stdexcept>
#include <string>
#include <sstream>
#include <utility> // Para std::swap y std::move
#include <functional> // Para std::function

template <typename TipoDato>
class ListaDoblementeLigada {
private:
    NodoDoblementeLigado<TipoDato>* punteroNodoInicio_; 
    NodoDoblementeLigado<TipoDato>* punteroNodoFinal_;      
    int cantidadElementosActuales_;                         

    NodoDoblementeLigado<TipoDato>* obtenerNodoEnPosicion(int posicion) const {
        if (posicion < 0 || posicion >= cantidadElementosActuales_) {
            return nullptr;
        }

        NodoDoblementeLigado<TipoDato>* nodoActual = nullptr;
        // Optimización: Buscar desde el inicio o desde el final según cercanía
        if (posicion < (cantidadElementosActuales_ / 2)) {
            nodoActual = punteroNodoInicio_;
            for (int i = 0; i < posicion; ++i) {
                nodoActual = nodoActual->punteroNodoSiguiente;
            }
        } 
        else {
            nodoActual = punteroNodoFinal_;
            for (int i = (cantidadElementosActuales_ - 1); i > posicion; --i) {
                nodoActual = nodoActual->punteroNodoPrevio;
            }
        }
        return nodoActual;
    }

public:
    // Constructor por defecto
    ListaDoblementeLigada()
        : punteroNodoInicio_(nullptr), punteroNodoFinal_(nullptr), cantidadElementosActuales_(0) {
    }

    // Constructor de Copia (Deep Copy) Seguro
    ListaDoblementeLigada(const ListaDoblementeLigada<TipoDato>& otraLista)
        : punteroNodoInicio_(nullptr), punteroNodoFinal_(nullptr), cantidadElementosActuales_(0) {
        try {
            NodoDoblementeLigado<TipoDato>* nodoActual = otraLista.punteroNodoInicio_;
            while (nodoActual != nullptr) {
                this->agregarAlFinal(nodoActual->datosAlmacenados);
                nodoActual = nodoActual->punteroNodoSiguiente;
            }
        } catch (...) {
            limpiarLista();
            throw;
        }
    }

    // Constructor de Movimiento (Move Constructor)
    ListaDoblementeLigada(ListaDoblementeLigada<TipoDato>&& otraLista) noexcept
        : punteroNodoInicio_(otraLista.punteroNodoInicio_),
        punteroNodoFinal_(otraLista.punteroNodoFinal_),
        cantidadElementosActuales_(otraLista.cantidadElementosActuales_) {
        
        otraLista.punteroNodoInicio_ = nullptr;
        otraLista.punteroNodoFinal_ = nullptr;
        otraLista.cantidadElementosActuales_ = 0;
    }

    // Destructor
    ~ListaDoblementeLigada() {
        limpiarLista();
    }

    // Operador de Asignación por Copia (Copy Assignment) - Idioma Copy-and-Swap
    ListaDoblementeLigada<TipoDato>& operator=(const ListaDoblementeLigada<TipoDato>& otraLista) {
        if (this != &otraLista) {
            ListaDoblementeLigada<TipoDato> copiaTemporal(otraLista);
            std::swap(punteroNodoInicio_, copiaTemporal.punteroNodoInicio_);
            std::swap(punteroNodoFinal_, copiaTemporal.punteroNodoFinal_);
            std::swap(cantidadElementosActuales_, copiaTemporal.cantidadElementosActuales_);
        }
        return *this;
    }

    // Operador de Asignación por Movimiento (Move Assignment)
    ListaDoblementeLigada<TipoDato>& operator=(ListaDoblementeLigada<TipoDato>&& otraLista) noexcept {
        if (this != &otraLista) {
            limpiarLista();
            punteroNodoInicio_ = otraLista.punteroNodoInicio_;
            punteroNodoFinal_ = otraLista.punteroNodoFinal_;
            cantidadElementosActuales_ = otraLista.cantidadElementosActuales_;

            otraLista.punteroNodoInicio_ = nullptr;
            otraLista.punteroNodoFinal_ = nullptr;
            otraLista.cantidadElementosActuales_ = 0;
        }
        return *this;
    }

    // --- MÉTODOS DE GESTIÓN ---

    void agregarAlFinal(const TipoDato& elementoNuevo) {
        NodoDoblementeLigado<TipoDato>* nodoNuevo = nullptr;
        try {
            nodoNuevo = new NodoDoblementeLigado<TipoDato>(elementoNuevo);
        } catch (const std::bad_alloc& e) {
            throw std::runtime_error("No hay memoria suficiente para agregar nodo.");
        }

        if (this->estaVacia()) {
            punteroNodoInicio_ = nodoNuevo;
            punteroNodoFinal_ = nodoNuevo;
        } else {
            punteroNodoFinal_->punteroNodoSiguiente = nodoNuevo;
            nodoNuevo->punteroNodoPrevio = punteroNodoFinal_;
            punteroNodoFinal_ = nodoNuevo;
        }
        cantidadElementosActuales_++;
    }

    void agregarAlInicio(const TipoDato& elementoNuevo) {
        NodoDoblementeLigado<TipoDato>* nodoNuevo = nullptr;
        try {
            nodoNuevo = new NodoDoblementeLigado<TipoDato>(elementoNuevo);
        } catch (const std::bad_alloc& e) {
            throw std::runtime_error("No hay memoria suficiente para agregar nodo.");
        }

        if (this->estaVacia()) {
            punteroNodoInicio_ = nodoNuevo;
            punteroNodoFinal_ = nodoNuevo;
        } else {
            nodoNuevo->punteroNodoSiguiente = punteroNodoInicio_;
            punteroNodoInicio_->punteroNodoPrevio = nodoNuevo;
            punteroNodoInicio_ = nodoNuevo;
        }
        cantidadElementosActuales_++;
    }

    void eliminarDelFinal() {
        if (estaVacia()) {
            throw std::underflow_error("No se puede eliminar de una lista vacía");
        }

        NodoDoblementeLigado<TipoDato>* nodoAeliminar = punteroNodoFinal_;

        if (cantidadElementosActuales_ == 1) {
            punteroNodoInicio_ = nullptr;
            punteroNodoFinal_ = nullptr;
        } else {
            punteroNodoFinal_ = punteroNodoFinal_->punteroNodoPrevio;
            punteroNodoFinal_->punteroNodoSiguiente = nullptr;
        }
        
        delete nodoAeliminar;
        cantidadElementosActuales_--;
    }

    void eliminarDelInicio() {
        if (estaVacia()) {
            throw std::underflow_error("No se puede eliminar de una lista vacía");
        }

        NodoDoblementeLigado<TipoDato>* nodoAeliminar = punteroNodoInicio_;

        if (cantidadElementosActuales_ == 1) {
            punteroNodoInicio_ = nullptr;
            punteroNodoFinal_ = nullptr;
        } else {
            punteroNodoInicio_ = punteroNodoInicio_->punteroNodoSiguiente;
            punteroNodoInicio_->punteroNodoPrevio = nullptr;
        }

        delete nodoAeliminar;
        cantidadElementosActuales_--;
    }

    void eliminarEnPosicion(int posicionEliminacion) {
        if (posicionEliminacion < 0 || posicionEliminacion >= cantidadElementosActuales_) {
            throw std::out_of_range("Posición inválida para eliminación");
        }

        if (posicionEliminacion == 0) {
            eliminarDelInicio();
            return;
        }

        if (posicionEliminacion == cantidadElementosActuales_ - 1) {
            eliminarDelFinal();
            return;
        }

        NodoDoblementeLigado<TipoDato>* nodoAeliminar = obtenerNodoEnPosicion(posicionEliminacion);
        NodoDoblementeLigado<TipoDato>* nodoPrevio = nodoAeliminar->punteroNodoPrevio;
        NodoDoblementeLigado<TipoDato>* nodoSiguiente = nodoAeliminar->punteroNodoSiguiente;

        nodoPrevio->punteroNodoSiguiente = nodoSiguiente;
        nodoSiguiente->punteroNodoPrevio = nodoPrevio;

        delete nodoAeliminar;
        cantidadElementosActuales_--;
    }

    // --- MÉTODOS DE ACCESO (LOS QUE TE FALTABAN) ---

    TipoDato& obtenerEnPosicion(int posicion) {
        NodoDoblementeLigado<TipoDato>* nodo = obtenerNodoEnPosicion(posicion);
        if (!nodo) throw std::out_of_range("Posición inválida: " + std::to_string(posicion));
        return nodo->datosAlmacenados;
    }

    const TipoDato& obtenerEnPosicion(int posicion) const {
        NodoDoblementeLigado<TipoDato>* nodo = obtenerNodoEnPosicion(posicion);
        if (!nodo) throw std::out_of_range("Posición inválida: " + std::to_string(posicion));
        return nodo->datosAlmacenados;
    }

    int obtenerCantidadElementos() const {
        return cantidadElementosActuales_;
    }

    bool estaVacia() const {
        return cantidadElementosActuales_ == 0;
    }

    // --- MÉTODOS DE UTILIDAD ---

    void limpiarLista() {
        NodoDoblementeLigado<TipoDato>* nodoActual = punteroNodoInicio_;
        while (nodoActual != nullptr) {
            NodoDoblementeLigado<TipoDato>* nodoSiguiente = nodoActual->punteroNodoSiguiente;
            delete nodoActual;
            nodoActual = nodoSiguiente;
        }
        punteroNodoInicio_ = nullptr;
        punteroNodoFinal_ = nullptr;
        cantidadElementosActuales_ = 0;
    }

    // Nuevo método para iteración eficiente (O(N) en vez de O(N^2))
    void paraCadaElemento(std::function<void(TipoDato&)> accion) {
        NodoDoblementeLigado<TipoDato>* actual = punteroNodoInicio_;
        while (actual != nullptr) {
            accion(actual->datosAlmacenados);
            actual = actual->punteroNodoSiguiente;
        }
    }

    void paraCadaElemento(std::function<void(const TipoDato&)> accion) const {
        NodoDoblementeLigado<TipoDato>* actual = punteroNodoInicio_;
        while (actual != nullptr) {
            accion(actual->datosAlmacenados);
            actual = actual->punteroNodoSiguiente;
        }
    }

    std::string obtenerRepresentacionTexto(std::string (*convertirATexto)(const TipoDato&)) const {
        std::stringstream representacion;
        NodoDoblementeLigado<TipoDato>* nodoActual = punteroNodoInicio_;
        int indiceElemento = 1;

        while (nodoActual != nullptr) {
            representacion << indiceElemento << ". " 
                          << convertirATexto(nodoActual->datosAlmacenados) 
                          << "\n";
            nodoActual = nodoActual->punteroNodoSiguiente;
            indiceElemento++;
        }
        return representacion.str();
    }

    void intercambiarDatos(int pos1, int pos2) {
        if (pos1 == pos2) return;

        NodoDoblementeLigado<TipoDato>* nodo1 = obtenerNodoEnPosicion(pos1);
        NodoDoblementeLigado<TipoDato>* nodo2 = obtenerNodoEnPosicion(pos2);

        if (nodo1 && nodo2) {
            TipoDato temp = std::move(nodo1->datosAlmacenados);
            nodo1->datosAlmacenados = std::move(nodo2->datosAlmacenados);
            nodo2->datosAlmacenados = std::move(temp);
        } else {
            throw std::out_of_range("Posición inválida para intercambio");
        }
    }
};


===== C:\Universidad\estructuras-de-datos\include\datastructures\templates\ListaSimplementeLigada.hpp =====
#pragma once

#include "NodoSimplementeLigado.hpp"
#include <stdexcept>
#include <string>
#include <sstream>
#include <utility> // Necesario para std::swap

template <typename TipoDato>
class ListaSimplementeLigada {
private:
    NodoSimplementeLigado<TipoDato>* punteroNodoInicio_; 
    NodoSimplementeLigado<TipoDato>* punteroNodoFinal_;   
    int cantidadElementosActuales_;                          

    NodoSimplementeLigado<TipoDato>* obtenerNodoEnPosicion(int posicion) const {
        if (posicion < 0 || posicion >= cantidadElementosActuales_) {
            return nullptr;
        }

        NodoSimplementeLigado<TipoDato>* nodoActual = punteroNodoInicio_;
        for (int i = 0; i < posicion; ++i) {
            nodoActual = nodoActual->punteroSiguienteNodo;
        }
        return nodoActual;
    }

public:
    ListaSimplementeLigada()
        : punteroNodoInicio_(nullptr),
        punteroNodoFinal_(nullptr),
        cantidadElementosActuales_(0) {
    }

    // Constructor de copia seguro
    ListaSimplementeLigada(const ListaSimplementeLigada<TipoDato>& otraLista)
        : punteroNodoInicio_(nullptr),
        punteroNodoFinal_(nullptr),
        cantidadElementosActuales_(0) {
        try {
            NodoSimplementeLigado<TipoDato>* nodoActual = otraLista.punteroNodoInicio_;
            while (nodoActual != nullptr) {
                this->agregarAlFinal(nodoActual->datosAlmacenados);
                nodoActual = nodoActual->punteroSiguienteNodo;
            }
        } catch (...) {
            limpiarLista();
            throw;
        }
    }

    // Constructor de movimiento
    ListaSimplementeLigada(ListaSimplementeLigada<TipoDato>&& otraLista) noexcept
        : punteroNodoInicio_(otraLista.punteroNodoInicio_),
        punteroNodoFinal_(otraLista.punteroNodoFinal_),
        cantidadElementosActuales_(otraLista.cantidadElementosActuales_) {
        
        otraLista.punteroNodoInicio_ = nullptr;
        otraLista.punteroNodoFinal_ = nullptr;
        otraLista.cantidadElementosActuales_ = 0;
    }

    ~ListaSimplementeLigada() {
        limpiarLista();
    }

    // CORRECCIÓN CRÍTICA: Copy-and-Swap para seguridad de excepciones
    ListaSimplementeLigada<TipoDato>& operator=(const ListaSimplementeLigada<TipoDato>& otraLista) {
        if (this != &otraLista) {
            // 1. Hacemos una copia temporal (si falla new, no pasa nada aquí)
            ListaSimplementeLigada<TipoDato> temporal(otraLista);
            
            // 2. Intercambiamos los punteros (operación atómica/segura)
            std::swap(punteroNodoInicio_, temporal.punteroNodoInicio_);
            std::swap(punteroNodoFinal_, temporal.punteroNodoFinal_);
            std::swap(cantidadElementosActuales_, temporal.cantidadElementosActuales_);
            
            // 3. Al salir, 'temporal' destruye los datos viejos automáticamente
        }
        return *this;
    }

    ListaSimplementeLigada<TipoDato>& operator=(ListaSimplementeLigada<TipoDato>&& otraLista) noexcept {
        if (this != &otraLista) {
            limpiarLista();
            punteroNodoInicio_ = otraLista.punteroNodoInicio_;
            punteroNodoFinal_ = otraLista.punteroNodoFinal_;
            cantidadElementosActuales_ = otraLista.cantidadElementosActuales_;

            otraLista.punteroNodoInicio_ = nullptr;
            otraLista.punteroNodoFinal_ = nullptr;
            otraLista.cantidadElementosActuales_ = 0;
        }
        return *this;
    }

    void agregarAlFinal(const TipoDato& elementoNuevo) {
        NodoSimplementeLigado<TipoDato>* nodoNuevo = 
            new NodoSimplementeLigado<TipoDato>(elementoNuevo);

        if (this->estaVacia()) {
            punteroNodoInicio_ = nodoNuevo;
            punteroNodoFinal_ = nodoNuevo;
        } else {
            punteroNodoFinal_->punteroSiguienteNodo = nodoNuevo;
            punteroNodoFinal_ = nodoNuevo;
        }
        cantidadElementosActuales_++;
    }

    void agregarAlInicio(const TipoDato& elementoNuevo) {
        NodoSimplementeLigado<TipoDato>* nodoNuevo = 
            new NodoSimplementeLigado<TipoDato>(elementoNuevo);

        if (this->estaVacia()) {
            punteroNodoInicio_ = nodoNuevo;
            punteroNodoFinal_ = nodoNuevo;
        } else {
            nodoNuevo->punteroSiguienteNodo = punteroNodoInicio_;
            punteroNodoInicio_ = nodoNuevo;
        }
        cantidadElementosActuales_++;
    }

    void agregarEnPosicion(int posicionInsercion, const TipoDato& elementoNuevo) {
        if (posicionInsercion < 0 || posicionInsercion > cantidadElementosActuales_) {
            throw std::out_of_range("Posición inválida para inserción");
        }

        if (posicionInsercion == 0) {
            agregarAlInicio(elementoNuevo);
            return;
        }

        if (posicionInsercion == cantidadElementosActuales_) {
            agregarAlFinal(elementoNuevo);
            return;
        }

        NodoSimplementeLigado<TipoDato>* nodoAnterior = obtenerNodoEnPosicion(posicionInsercion - 1);
        NodoSimplementeLigado<TipoDato>* nodoNuevo = 
            new NodoSimplementeLigado<TipoDato>(elementoNuevo);

        nodoNuevo->punteroSiguienteNodo = nodoAnterior->punteroSiguienteNodo;
        nodoAnterior->punteroSiguienteNodo = nodoNuevo;
        cantidadElementosActuales_++;
    }

    void eliminarDelFinal() {
        if (estaVacia()) {
            throw std::underflow_error("No se puede eliminar de una lista vacía");
        }

        if (cantidadElementosActuales_ == 1) {
            delete punteroNodoInicio_;
            punteroNodoInicio_ = nullptr;
            punteroNodoFinal_ = nullptr;
        } else {
            // O(N) es inevitable en lista simple sin puntero previo
            NodoSimplementeLigado<TipoDato>* nodoAnteriorAlFinal = 
                obtenerNodoEnPosicion(cantidadElementosActuales_ - 2);
            
            delete punteroNodoFinal_;
            punteroNodoFinal_ = nodoAnteriorAlFinal;
            punteroNodoFinal_->punteroSiguienteNodo = nullptr;
        }
        cantidadElementosActuales_--;
    }

    void eliminarDelInicio() {
        if (estaVacia()) {
            throw std::underflow_error("No se puede eliminar de una lista vacía");
        }

        NodoSimplementeLigado<TipoDato>* nodoAeliminar = punteroNodoInicio_;
        punteroNodoInicio_ = punteroNodoInicio_->punteroSiguienteNodo;

        if (cantidadElementosActuales_ == 1) {
            punteroNodoFinal_ = nullptr;
        }

        delete nodoAeliminar;
        cantidadElementosActuales_--;
    }

    void eliminarEnPosicion(int posicionEliminacion) {
        if (posicionEliminacion < 0 || posicionEliminacion >= cantidadElementosActuales_) {
            throw std::out_of_range("Posición inválida para eliminación");
        }

        if (posicionEliminacion == 0) {
            eliminarDelInicio();
            return;
        }

        // Optimización: si borran el último, usar la lógica de eliminarDelFinal
        // para mantener punteroNodoFinal_ correcto
        if (posicionEliminacion == cantidadElementosActuales_ - 1) {
            eliminarDelFinal();
            return;
        }

        NodoSimplementeLigado<TipoDato>* nodoAnterior = 
            obtenerNodoEnPosicion(posicionEliminacion - 1);
        NodoSimplementeLigado<TipoDato>* nodoAeliminar = nodoAnterior->punteroSiguienteNodo;

        nodoAnterior->punteroSiguienteNodo = nodoAeliminar->punteroSiguienteNodo;
        delete nodoAeliminar;
        cantidadElementosActuales_--;
    }

    TipoDato& obtenerEnPosicion(int posicion) {
        NodoSimplementeLigado<TipoDato>* nodo = obtenerNodoEnPosicion(posicion);
        if (!nodo) throw std::out_of_range("Posición inválida");
        return nodo->datosAlmacenados;
    }

    const TipoDato& obtenerEnPosicion(int posicion) const {
        NodoSimplementeLigado<TipoDato>* nodo = obtenerNodoEnPosicion(posicion);
        if (!nodo) throw std::out_of_range("Posición inválida");
        return nodo->datosAlmacenados;
    }

    bool estaVacia() const {
        return cantidadElementosActuales_ == 0;
    }

    int obtenerCantidadElementos() const {
        return cantidadElementosActuales_;
    }

    void limpiarLista() {
        NodoSimplementeLigado<TipoDato>* nodoActual = punteroNodoInicio_;
        while (nodoActual != nullptr) {
            NodoSimplementeLigado<TipoDato>* nodoSiguiente = nodoActual->punteroSiguienteNodo;
            delete nodoActual;
            nodoActual = nodoSiguiente;
        }
        punteroNodoInicio_ = nullptr;
        punteroNodoFinal_ = nullptr;
        cantidadElementosActuales_ = 0;
    }

    // ... (Iteradores y to string se mantienen igual)
    std::string obtenerRepresentacionTexto(
        std::string (*convertirATexto)(const TipoDato&)
    ) const {
        std::stringstream representacion;
        NodoSimplementeLigado<TipoDato>* nodoActual = punteroNodoInicio_;
        int indiceElemento = 1;

        while (nodoActual != nullptr) {
            representacion << indiceElemento << ". " 
            << convertirATexto(nodoActual->datosAlmacenados) 
            << "\n";
            nodoActual = nodoActual->punteroSiguienteNodo;
            indiceElemento++;
        }

        return representacion.str();
    }
};


===== C:\Universidad\estructuras-de-datos\include\datastructures\templates\NodoCircularDoble.hpp =====


===== C:\Universidad\estructuras-de-datos\include\datastructures\templates\NodoDoblementeLigado.hpp =====
#pragma once
#include <cstddef> 

template <typename TipoDato>
class NodoDoblementeLigado {
public:
    TipoDato datosAlmacenados;     
    NodoDoblementeLigado<TipoDato>* punteroNodoPrevio; 
    NodoDoblementeLigado<TipoDato>* punteroNodoSiguiente; 
    NodoDoblementeLigado(const TipoDato& datos)
        : datosAlmacenados(datos),
          punteroNodoPrevio(nullptr),
          punteroNodoSiguiente(nullptr) {
    }

    NodoDoblementeLigado(const NodoDoblementeLigado<TipoDato>& otroNodo)
        : datosAlmacenados(otroNodo.datosAlmacenados),
          punteroNodoPrevio(otroNodo.punteroNodoPrevio),
          punteroNodoSiguiente(otroNodo.punteroNodoSiguiente) {
    }

  ~NodoDoblementeLigado() {
    }
};


===== C:\Universidad\estructuras-de-datos\include\datastructures\templates\NodoSimplementeLigado.hpp =====
#pragma once
#include <memory>

template <typename TipoDato>
class NodoSimplementeLigado {
public:
    TipoDato datosAlmacenados;     
    NodoSimplementeLigado<TipoDato>* punteroSiguienteNodo;

    NodoSimplementeLigado(const TipoDato& datosIngresados)
        : datosAlmacenados(datosIngresados), punteroSiguienteNodo(nullptr) {
    }

    NodoSimplementeLigado(TipoDato&& datosIngresados)
        : datosAlmacenados(std::move(datosIngresados)),  punteroSiguienteNodo(nullptr) {
    }

    ~NodoSimplementeLigado() = default;

    bool tieneNodoSiguiente() const {
        return punteroSiguienteNodo != nullptr;
    }

    void vincularConSiguienteNodo(NodoSimplementeLigado<TipoDato>* nodoSiguiente) {
        punteroSiguienteNodo = nodoSiguiente;
    }

    NodoSimplementeLigado<TipoDato>* obtenerNodoSiguiente() const {
        return punteroSiguienteNodo;
    }

    TipoDato& obtenerDatos() {
        return datosAlmacenados;
    }

    const TipoDato& obtenerDatosConstantes() const {
        return datosAlmacenados;
    }
};


// ============================================================================
// TEMPLATE: NodoCircularDoble<T>
// Nodo para lista circular doblemente ligada
// CaracterÃ­sticas:
// - Almacena un dato de tipo genÃ©rico T
// - Contiene punteros al nodo anterior Y siguiente
// - Permite navegaciÃ³n bidireccional
// - Puede forma cÃ­rculos (Ãºtil para colas circulares)
// ============================================================================
template <typename TipoDato>
class NodoCircularDoble {
public:
    TipoDato datosAlmacenados;                              // El dato
    NodoCircularDoble<TipoDato>* punteroAnteriorNodo;      // Puntero anterior
    NodoCircularDoble<TipoDato>* punteroSiguienteNodo;     // Puntero siguiente

    // ========================================================================
    // CONSTRUCTORES
    // ========================================================================
    
    // Constructor parametrizado
    NodoCircularDoble(const TipoDato& datosIngresados)
        : datosAlmacenados(datosIngresados),
          punteroAnteriorNodo(nullptr),
          punteroSiguienteNodo(nullptr) {
    }

    // Constructor de movimiento
    NodoCircularDoble(TipoDato&& datosIngresados)
        : datosAlmacenados(std::move(datosIngresados)),
          punteroAnteriorNodo(nullptr),
          punteroSiguienteNodo(nullptr) {
    }

    // Destructor
    ~NodoCircularDoble() = default;

    // ========================================================================
    // MÃ‰TODOS AUXILIARES - ValidaciÃ³n
    // ========================================================================
    
    // Verificar si existe nodo siguiente
    bool tieneNodoSiguiente() const {
        return punteroSiguienteNodo != nullptr;
    }

    // Verificar si existe nodo anterior
    bool tieneNodoAnterior() const {
        return punteroAnteriorNodo != nullptr;
    }

    // ========================================================================
    // MÃ‰TODOS AUXILIARES - NavegaciÃ³n (vincular)
    // ========================================================================
    
    // Vincular con nodo anterior
    void vincularAnterior(NodoCircularDoble<TipoDato>* nodoAnterior) {
        punteroAnteriorNodo = nodoAnterior;
    }

    // Vincular con nodo siguiente
    void vincularSiguiente(NodoCircularDoble<TipoDato>* nodoSiguiente) {
        punteroSiguienteNodo = nodoSiguiente;
    }

    // Vincular bidireccional con otro nodo (conecta ambas direcciones)
    void vincularBidireccional(NodoCircularDoble<TipoDato>* nodoAnterior,
                              NodoCircularDoble<TipoDato>* nodoSiguiente) {
        punteroAnteriorNodo = nodoAnterior;
        punteroSiguienteNodo = nodoSiguiente;
    }

    // ========================================================================
    // MÃ‰TODOS AUXILIARES - NavegaciÃ³n (obtener)
    // ========================================================================
    
    // Obtener nodo siguiente
    NodoCircularDoble<TipoDato>* obtenerNodoSiguiente() const {
        return punteroSiguienteNodo;
    }

    // Obtener nodo anterior
    NodoCircularDoble<TipoDato>* obtenerNodoAnterior() const {
        return punteroAnteriorNodo;
    }

    // ========================================================================
    // MÃ‰TODOS AUXILIARES - Acceso a datos
    // ========================================================================
    
    // Obtener datos (modificable)
    TipoDato& obtenerDatos() {
        return datosAlmacenados;
    }

    // Obtener datos (constante)
    const TipoDato& obtenerDatosConstantes() const {
        return datosAlmacenados;
    }

    // ========================================================================
    // MÃ‰TODO ESPECIAL - Para depuraciÃ³n
    // ========================================================================
    
    // InformaciÃ³n si estÃ¡ completamente desvinculado
    bool estaDesvinculado() const {
        return punteroAnteriorNodo == nullptr && punteroSiguienteNodo == nullptr;
    }

    // InformaciÃ³n si es un nodo circular (apunta a sÃ­ mismo)
    bool esCircular() const {
        return (punteroAnteriorNodo == this && punteroSiguienteNodo == this);
    }
};


===== C:\Universidad\estructuras-de-datos\include\datastructures\templates\PilaDinamica.hpp =====
#pragma once

#include "datastructures/templates/ListaSimplementeLigada.hpp"
#include <stdexcept>

template <typename TipoDato>
class PilaDinamica {
private:
    ListaSimplementeLigada<TipoDato> listaContenedora;

public:
    PilaDinamica() {}
    
    PilaDinamica(const PilaDinamica<TipoDato>& otraPila) 
        : listaContenedora(otraPila.listaContenedora) {}

    ~PilaDinamica() {
    }

    void apilar(const TipoDato& elementoNuevo) {
        listaContenedora.agregarAlInicio(elementoNuevo);
    }

    void desapilar() {
        if (estaVacia()) {
            throw std::underflow_error("Error: Intento de desapilar una pila vacÃ­a.");
        }
        listaContenedora.eliminarDelInicio();
    }

    TipoDato& consultarTope() {
        if (estaVacia()) {
            throw std::underflow_error("Error: Intento de consultar tope de pila vacÃ­a.");
        }
        return listaContenedora.obtenerEnPosicion(0);
    }

    bool estaVacia() const {
        return listaContenedora.estaVacia();
    }

    int obtenerCantidadElementos() const {
        return listaContenedora.obtenerCantidadElementos();
    }

    void limpiarPila() {
        listaContenedora.limpiarLista();
    }
};


===== C:\Universidad\estructuras-de-datos\include\datastructures\templates\PilaEstatica.hpp =====
#pragma once
#include <stdexcept>
#include <string>
#include <sstream>

template <typename TipoDato, int CAPACIDAD_MAXIMA = 1000>
class PilaEstatica {
private:
    TipoDato* arregloDatos_;                 // Arreglo dinÃ¡mico
    int posicionTopePila_;                   // PosiciÃ³n del tope (-1 = vacÃ­a)
    int capacidadMaxima_;                    // Capacidad mÃ¡xima

public:
    PilaEstatica()
        : posicionTopePila_(-1), capacidadMaxima_(CAPACIDAD_MAXIMA) {
        arregloDatos_ = new TipoDato[capacidadMaxima_];
    }

    PilaEstatica(const PilaEstatica& otraPila)
        : posicionTopePila_(otraPila.posicionTopePila_), capacidadMaxima_(otraPila.capacidadMaxima_) {
            arregloDatos_ = new TipoDato[capacidadMaxima_];
                for (int i = 0; i <= posicionTopePila_; ++i) {
                    arregloDatos_[i] = otraPila.arregloDatos_[i];
                }
    }

    PilaEstatica& operator=(const PilaEstatica& otraPila) {
        if (this != &otraPila) {
            delete[] arregloDatos_;
            posicionTopePila_ = otraPila.posicionTopePila_;
            capacidadMaxima_ = otraPila.capacidadMaxima_;
            arregloDatos_ = new TipoDato[capacidadMaxima_];
            
            for (int i = 0; i <= posicionTopePila_; ++i) {
                arregloDatos_[i] = otraPila.arregloDatos_[i];
            }
        }
        return *this;
    }

    ~PilaEstatica() {
        delete[] arregloDatos_;
    }

    void apilarElemento(const TipoDato& elementoNuevo) {
        if (estaPilaLlena()) {
            throw std::overflow_error(
                "Pila estÃ¡tica llena. No se puede apilar mÃ¡s elementos."
            );
        }
        posicionTopePila_++;
        arregloDatos_[posicionTopePila_] = elementoNuevo;
    }

    void apilarElementoPorMovimiento(TipoDato&& elementoNuevo) {
        if (estaPilaLlena()) {
            throw std::overflow_error("Pila estÃ¡tica llena");
        }
        posicionTopePila_++;
        arregloDatos_[posicionTopePila_] = std::move(elementoNuevo);
    }

    TipoDato desapilarElemento() {
        if (estaPilaVacia()) {
            throw std::underflow_error(
                "Pila estÃ¡tica vacÃ­a. No se puede desapilar."
            );
        }
        TipoDato elementoSacado = arregloDatos_[posicionTopePila_];
        posicionTopePila_--;
        return elementoSacado;
    }

    TipoDato& obtenerTopePila() {
        if (estaPilaVacia()) {
            throw std::underflow_error("Pila estÃ¡tica vacÃ­a. No hay tope.");
        }
        return arregloDatos_[posicionTopePila_];
    }

    const TipoDato& obtenerTopeConsante() const {
        if (estaPilaVacia()) {
            throw std::underflow_error("Pila estÃ¡tica vacÃ­a");
        }
        return arregloDatos_[posicionTopePila_];
    }

    bool estaPilaVacia() const {
        return posicionTopePila_ == -1;
    }

    bool estaPilaLlena() const {
        return posicionTopePila_ == (capacidadMaxima_ - 1);
    }

    int obtenerCantidadElementos() const {
        return posicionTopePila_ + 1;
    }

    int obtenerCapacidadMaxima() const {
        return capacidadMaxima_;
    }

    void vaciarPila() {
        posicionTopePila_ = -1;
    }

    float obtenerPorcentajeUso() const {
        return (100.0f * obtenerCantidadElementos()) / capacidadMaxima_;
    }

    std::string obtenerRepresentacionTexto(
        std::string (*convertirATexto)(const TipoDato&)
    ) const {
        std::stringstream representacion;
        representacion << "Pila Estatica (tope â†’ base):\n";
        representacion << "Capacidad: " << obtenerCantidadElementos() << "/" << capacidadMaxima_ << "\n\n";
        
        if (estaPilaVacia()) {
            representacion << "[VacÃ­a]\n";
            return representacion.str();
        }

        for (int i = posicionTopePila_; i >= 0; --i) {
            representacion << "[" << convertirATexto(arregloDatos_[i]) << "]\n";
        }
        return representacion.str();
    }
};


===== C:\Universidad\estructuras-de-datos\include\entities\Categoria.hpp =====
#pragma once
#include <string>

enum class Categoria {
    DESAYUNO = 0,
    COMIDA,
    CENA,
    NAVIDENO,
    SIN_CATEGORIZAR
};

// Declaración de la función para que sea visible globalmente
std::string categoriaATexto(Categoria categoria);


===== C:\Universidad\estructuras-de-datos\include\entities\Ingrediente.hpp =====
#pragma once
#include <string>
#include <iostream>
#include <stdexcept>

class Ingrediente {
private:
    std::string nombreIngrediente;      // Nombre del ingrediente
    std::string cantidadIngrediente;    // Cantidad (ej: "2", "1/2", "3.5")
    std::string unidadMedida;           // Unidad (ej: "tazas", "gramos", "piezas")

public:
    Ingrediente();
    
    Ingrediente(const std::string& nombre, const std::string& cantidad, const std::string& unidad);
    
    Ingrediente(const Ingrediente& otro);
    
    Ingrediente(Ingrediente&& otro) noexcept;

    Ingrediente& operator=(const Ingrediente& otro);
    
    Ingrediente& operator=(Ingrediente&& otro) noexcept;

    bool operator==(const Ingrediente& otro) const;
    
    bool operator<(const Ingrediente& otro) const;

    static int compararPorNombre(const Ingrediente& ing1, const Ingrediente& ing2);

    std::string obtenerNombre() const { 
        return nombreIngrediente; 
    }
    
    std::string obtenerCantidad() const { 
        return cantidadIngrediente; 
    }
    
    std::string obtenerUnidad() const { 
        return unidadMedida; 
    }
    void establecerNombre(const std::string& nombre) { 
        nombreIngrediente = nombre; 
    }
    
    void establecerCantidad(const std::string& cantidad) { 
        cantidadIngrediente = cantidad; 
    }
    
    void establecerUnidad(const std::string& unidad) { 
        unidadMedida = unidad; 
    }

    std::string toString() const;

    std::string obtenerRepresentacionFormateada() const;

    friend std::ostream& operator<<(std::ostream& salida, const Ingrediente& ing);
    
    // Lectura desde stream (para cargar desde archivos)
    friend std::istream& operator>>(std::istream& entrada, Ingrediente& ing);
};


===== C:\Universidad\estructuras-de-datos\include\entities\Nombre.hpp =====
#pragma once
#include <string>
#include <iostream>
#include <cctype>
#include <algorithm>
#include <stdexcept>

class Nombre {
private:
    std::string primerNombre;
    std::string apellidoPrimero;
    std::string apellidoSegundo;

    void validarYnormalizarNombre(std::string& texto);

public:

    Nombre();
    
    Nombre(const std::string& primerNombreIngreso, const std::string& apellidoUno, const std::string& apellidoDos = "");
    
    Nombre(const Nombre& otroNombre);
    
    Nombre(Nombre&& otroNombre) noexcept;

    Nombre& operator = (const Nombre& otroNombre);
    Nombre& operator = (Nombre&& otroNombre) noexcept;

    bool operator == (const Nombre& otroNombre) const;
    bool operator<(const Nombre& otroNombre) const;

    std::string obtenerPrimerNombre() const { 
        return primerNombre; 
    }
    
    std::string obtenerApellidoPrimero() const { 
        return apellidoPrimero; 
    }
    
    std::string obtenerApellidoSegundo() const { 
        return apellidoSegundo; 
    }

    void establecerPrimerNombre(const std::string& nombre);
        void establecerApellidos(const std::string& apl1, const std::string& apl2 = "");
    
    std::string obtenerNombreCompleto() const;
    //
    std::string obtenerIniciales() const;
    
    std::string toString() const;

    friend std::ostream& operator<<(std::ostream& salida, const Nombre& nombre);
    
    friend std::istream& operator>>(std::istream& entrada, Nombre& nombre);
}; //////////// HAHASHAHSAHSAHSHASAHSHASHASAS


===== C:\Universidad\estructuras-de-datos\include\entities\Receta.hpp =====
// ============================================================================
// ARCHIVO: include/entities/Receta.hpp
// Definición de la clase Receta
// ============================================================================
#pragma once
#include <string>
#include <iostream>
#include <stdexcept>
#include "entities/Nombre.hpp"
#include "entities/Ingrediente.hpp"
#include "entities/Categoria.hpp"
#include "datastructures/templates/ListaSimplementeLigada.hpp"

class Receta {
private:
    std::string nombrePlatillo;                        
    Nombre autorReceta;                              
    Categoria categoriaReceta;                        
    int tiempoPreparacionMinutos;                       
    std::string procedimientoPasos;                      
    ListaSimplementeLigada<Ingrediente> ingredientesListaOrdenada;  
    std::string rutaImagenPlatillo;                     

public:
    Receta();
    
    Receta(const std::string& nombrePlatillo_, const Nombre& autor, const Categoria& categoria, int tiempoMinutos, const std::string& procedimiento);
    
    Receta(const Receta& otraReceta);
    Receta(Receta&& otraReceta) noexcept;
    Receta& operator=(const Receta& otraReceta);
    Receta& operator=(Receta&& otraReceta) noexcept;

    bool operator==(const Receta& otraReceta) const;
    bool operator<(const Receta& otraReceta) const;

    static int compararPorNombre(const Receta& rec1, const Receta& rec2);
    static int compararPorTiempoPreparacion(const Receta& rec1, const Receta& rec2);
    static int compararPorCategoria(const Receta& rec1, const Receta& rec2);
    static int compararPorAutor(const Receta& rec1, const Receta& rec2);

    std::string obtenerNombrePlatillo() const { 
        return nombrePlatillo; 
    }
    
    Nombre obtenerAutor() const { 
        return autorReceta; 
    }
    
    Categoria obtenerCategoria() const { 
        return categoriaReceta; 
    }
    
    int obtenerTiempoPreparacion() const { 
        return tiempoPreparacionMinutos; 
    }
    
    std::string obtenerProcedimiento() const { 
        return procedimientoPasos; 
    }
    
    ListaSimplementeLigada<Ingrediente>& obtenerIngredientes() { 
        return ingredientesListaOrdenada; 
    }
    
    const ListaSimplementeLigada<Ingrediente>& obtenerIngredientesConstante() const { 
        return ingredientesListaOrdenada; 
    }
    
    std::string obtenerRutaImagen() const { 
        return rutaImagenPlatillo; 
    }

    void establecerNombrePlatillo(const std::string& nombre) { 
        nombrePlatillo = nombre; 
    }
    
    void establecerAutor(const Nombre& autor) { 
        autorReceta = autor; 
    }
    
    void establecerCategoria(const Categoria& categoria) { 
        categoriaReceta = categoria; 
    }
    
    void establecerTiempoPreparacion(int minutos) { 
        tiempoPreparacionMinutos = minutos; 
    }
    
    void establecerProcedimiento(const std::string& procedimiento) { 
        procedimientoPasos = procedimiento; 
    }
    
    void establecerRutaImagen(const std::string& ruta) { 
        rutaImagenPlatillo = ruta; 
    }

    void agregarIngredienteOrdenado(const Ingrediente& ingrediente);
    
    void eliminarIngredientePorNombre(const std::string& nombreIngrediente);
    
    void eliminarTodosLosIngredientes();
    
    bool verificarSiIngredienteExiste(const std::string& nombreBuscado) const;
    
    Ingrediente& obtenerIngredientePorNombre(const std::string& nombreBuscado);
    
    void modificarCantidadIngrediente(const std::string& nombreIngrediente, const std::string& nuevaCantidad);

    std::string toString() const;
    
    std::string obtenerResumenCorto() const;
    
    std::string obtenerDetalleCompleto() const;
    
    int obtenerCantidadIngredientes() const { 
        return ingredientesListaOrdenada.obtenerCantidadElementos(); 
    }

    // ========================================================================
    // OPERADORES DE FLUJO - Serialización
    // ========================================================================
    
    // Escritura a stream (para guardar en archivos)
    friend std::ostream& operator<<(std::ostream& salida, const Receta& receta);
    
    // Lectura desde stream (para cargar desde archivos)
    friend std::istream& operator>>(std::istream& entrada, Receta& receta);
};


===== C:\Universidad\estructuras-de-datos\include\persistence\ManejadorArchivosIngredientes.hpp =====


===== C:\Universidad\estructuras-de-datos\include\persistence\ManejadorArchivosRecetas.hpp =====
#pragma once
#include <string>
#include <vector>

struct InfoArchivo {
    std::string ruta;
    bool existe;
    long tamanoByte;
    std::string fechaUltimaModificacion;
};

class ManejadorArchivosRecetas {
private:
    // Solo metodos auxiliares privados
    static void crearRespaldo(const std::string& rutaArchivo);

public:
    ManejadorArchivosRecetas() = delete;

    static InfoArchivo obtenerInformacionArchivo(const std::string& rutaArchivo);
    static bool crearArchivoSiNoExiste(const std::string& rutaArchivo);
    static bool eliminarArchivo(const std::string& rutaArchivo);
    static bool renombrarArchivo(const std::string& rutaActual, const std::string& rutaNueva);
    static bool crearRespaldoAutomatico(const std::string& rutaArchivo);
    static bool restaurarDesdeRespaldo(const std::string& rutaRespaldo, const std::string& rutaDestino);
    static bool verificarIntegridad(const std::string& rutaArchivo);
    static void limpiarArchivosAntiguos(const std::string& ruta, int diasAntiguedad);
};


===== C:\Universidad\estructuras-de-datos\include\persistence\ManejadorIngredientes.hpp =====
/*
#include "datastructures/managers/ManejadorIngredientes.hpp"

ManejadorIngredientes::ManejadorIngredientes() {}
ManejadorIngredientes::~ManejadorIngredientes() {}
*/
#pragma once

class ManejadorIngredientes {
public:
    ManejadorIngredientes() {}
    ~ManejadorIngredientes() {}
};


===== C:\Universidad\estructuras-de-datos\include\persistence\RutasAssets.hpp =====
#pragma once
#include <string>
#include "entities/Categoria.hpp"
#include <cctype> 

class RutasAssets {
private:
    static const std::string RUTA_RELATIVA_ASSETS;
    static const std::string RUTA_RELATIVA_FONTS;
    static const std::string RUTA_RELATIVA_ICONS;
    static const std::string RUTA_RELATIVA_PLATILLOS;
    static const std::string RUTA_RELATIVA_DATA;

    RutasAssets() = delete;

public:

    static std::string obtenerRutaFuenteRegular();
    static std::string obtenerRutaFuenteNegrita();
    
    static std::string obtenerRutaIconoBotonAgregar();
    static std::string obtenerRutaIconoBotonEditar();
    static std::string obtenerRutaIconoBotonEliminar();
    static std::string obtenerRutaIconoBotonVolver();
    static std::string obtenerRutaIconoBotonGuardar();

    static std::string obtenerRutaImagenPlatillo( const Categoria& categoria, const std::string& nombrePlatillo );
    static std::string obtenerRutaCarpetaImagenesPorCategoria(const Categoria& categoria);
    static std::string obtenerRutaArchivoRecetario();
};


===== C:\Universidad\estructuras-de-datos\include\ui\Boton.hpp =====
#pragma once
#include <SDL3/SDL.h>
#include <string>

class Boton {
private:
    SDL_FRect rectOriginal;
    SDL_FRect rectActual;
    SDL_Texture* textura;
    bool activo;
    bool hover;

public:
    Boton(SDL_Renderer* renderer, const std::string& rutaImagen, float x, float y, float w, float h);
    ~Boton();

    // NUEVO: Permite cambiar la textura del botón dinámicamente
    void cambiarImagen(SDL_Renderer* renderer, const std::string& nuevaRuta);

    void actualizar();
    void render(SDL_Renderer* renderer);
    bool estaPresionado(float mouseX, float mouseY) const;
    
    void setActivo(bool a) { activo = a; }
    bool esActivo() const { return activo; }
};


===== C:\Universidad\estructuras-de-datos\include\ui\CajaDeTexto.hpp =====
#pragma once
#include <SDL3/SDL.h>
#include <SDL3_ttf/SDL_ttf.h>
#include <string>

class CajaDeTexto {
private:
    SDL_Window* ventana; // Referencia a la ventana para activar inputs
    SDL_FRect rect;
    std::string texto;
    std::string placeholder;
    bool tieneFoco;
    TTF_Font* fuente;
    SDL_Texture* texturaTexto;
    
    SDL_Color colorFondo = {255, 255, 255, 255};
    SDL_Color colorBorde = {0, 0, 0, 255};
    SDL_Color colorTexto = {0, 0, 0, 255};
    SDL_Color colorPlaceholder = {150, 150, 150, 255};

    void regenerarTextura(SDL_Renderer* renderer);

public:
    // Constructor actualizado con SDL_Window*
    CajaDeTexto(SDL_Window* win, float x, float y, float w, float h, TTF_Font* f);
    ~CajaDeTexto();

    void manejarEvento(const SDL_Event& evento);
    void render(SDL_Renderer* renderer);
    
    std::string obtenerTexto() const { return texto; }
    void establecerTexto(const std::string& t);
    void establecerPlaceholder(const std::string& p) { placeholder = p; }
    
    bool estaActiva() const { return tieneFoco; }
};


===== C:\Universidad\estructuras-de-datos\include\ui\ElementosUIReutilizables.hpp =====


===== C:\Universidad\estructuras-de-datos\include\ui\GameState.hpp =====
#pragma once

// [SENTINEL FIX] Forward Declaration para romper dependencia circular
class Game;

class GameState {
public:
    virtual ~GameState() {}
    
    // MÃ©todos virtuales puros que DEBEN ser implementados por cualquier pantalla
    virtual void init(Game& game) = 0;
    virtual void cleanup() = 0;
    virtual void handleEvents(Game& game) = 0;
    virtual void update(Game& game) = 0;
    virtual void render(Game& game) = 0;

protected:
    GameState() {}
};


===== C:\Universidad\estructuras-de-datos\include\ui\Pantalla.hpp =====


===== C:\Universidad\estructuras-de-datos\include\ui\PantallaAgregarReceta.hpp =====
#pragma once
#include "ui/GameState.hpp"
#include "ui/Boton.hpp"
#include "ui/CajaDeTexto.hpp"
#include "entities/Categoria.hpp"
#include "entities/Ingrediente.hpp"
#include "entities/Receta.hpp"
#include "datastructures/templates/ListaSimplementeLigada.hpp"
#include <SDL3/SDL.h>
#include <SDL3_ttf/SDL_ttf.h>
#include <vector>
#include <string>

struct ItemIngredienteVisual {
    SDL_Texture* textura;
    SDL_FRect rect;
};

class Game; 

class PantallaAgregarReceta : public GameState {
private:
    TTF_Font* fuenteTitulo;
    TTF_Font* fuenteLabels;
    TTF_Font* fuenteInputs;
    TTF_Font* fuenteLista;
    TTF_Font* fuenteUI;

    SDL_Texture* texturaTitulo;
    SDL_FRect rectTitulo;

    CajaDeTexto* inputNombre;
    CajaDeTexto* inputAutor;
    CajaDeTexto* inputTiempo;
    CajaDeTexto* inputProcedimiento;

    CajaDeTexto* inputIngNombre;
    CajaDeTexto* inputIngCant;
    CajaDeTexto* inputIngUnidad;
    Boton* btnAgregarIngrediente;
    Boton* btnQuitarIngrediente;

    SDL_Texture* texPreviewImagen;
    SDL_FRect rectPreviewImagen;
    std::string rutaImagenTemporal; 
    bool imagenCargada;

    ListaSimplementeLigada<Ingrediente> listaIngredientesTemp;
    std::vector<ItemIngredienteVisual> listaVisualIngredientes;
    void agregarIngredienteALista(SDL_Renderer* renderer);
    void eliminarUltimoIngrediente();

    Categoria categoriaSeleccionada;
    Boton* btnCambiarCategoria;
    SDL_Texture* texturaCategoriaActual;
    SDL_FRect rectCategoria;
    void actualizarTextoCategoria(SDL_Renderer* renderer);

    Boton* btnGuardar;
    Boton* btnCancelar;
    
    bool modoEdicion;
    std::string tempNombre;
    std::string tempAutor;
    std::string tempTiempo;
    std::string tempProc;
    std::string nombreOriginal; // ID para borrar la vieja

    void guardarReceta(Game& game);
    void procesarArchivoDroppeado(SDL_Renderer* renderer, const char* ruta);

public:
    PantallaAgregarReceta();
    PantallaAgregarReceta(const Receta& recetaAEditar);
    virtual ~PantallaAgregarReceta();

    void init(Game& game) override;
    void cleanup() override;
    void handleEvents(Game& game) override;
    void update(Game& game) override;
    void render(Game& game) override;
};


===== C:\Universidad\estructuras-de-datos\include\ui\PantallaBusquedaOrdenamiento.hpp =====
#pragma once
#include "ui/GameState.hpp"
#include "ui/Boton.hpp"
#include "ui/CajaDeTexto.hpp"
#include <vector>

class PantallaBusquedaOrdenamiento : public GameState {
private:
    TTF_Font* fuenteTitulo;
    TTF_Font* fuenteDetalle;
    SDL_Texture* texturaTitulo;
    SDL_FRect rectTitulo;

    // Botones de Ordenamiento
    Boton* btnOrdenarNombre;
    Boton* btnOrdenarTiempo;
    Boton* btnVolver;

    // Búsqueda
    CajaDeTexto* inputBusqueda;
    Boton* btnBuscar;

    // Resultado
    std::string resultadoTexto;
    SDL_Texture* texturaResultado;
    SDL_FRect rectResultado;

    void actualizarTextoResultado(SDL_Renderer* renderer, const std::string& texto);

public:
    PantallaBusquedaOrdenamiento();
    ~PantallaBusquedaOrdenamiento();

    void init(Game& game) override;
    void cleanup() override;
    void handleEvents(Game& game) override;
    void update(Game& game) override;
    void render(Game& game) override;
};


===== C:\Universidad\estructuras-de-datos\include\ui\PantallaDetalleReceta.hpp =====
#pragma once
#include "ui/GameState.hpp"
#include "ui/Boton.hpp"
#include "entities/Receta.hpp"
#include <SDL3/SDL.h>
#include <SDL3_ttf/SDL_ttf.h>

class PantallaDetalleReceta : public GameState {
private:
    Receta recetaAMostrar;

    TTF_Font* fuenteTitulo;
    TTF_Font* fuenteSubtitulo;
    TTF_Font* fuenteTexto;

    SDL_Texture* texTitulo;
    SDL_FRect rectTitulo;
    
    // IMAGEN
    SDL_Texture* texImagenPlatillo;
    SDL_FRect rectImagenPlatillo;

    Boton* btnVolver;

    void renderizarInfoGeneral(SDL_Renderer* renderer, int w);
    void renderizarIngredientes(SDL_Renderer* renderer, int w);
    void renderizarProcedimiento(SDL_Renderer* renderer, int w, int h);

public:
    PantallaDetalleReceta(const Receta& receta);
    ~PantallaDetalleReceta();

    void init(Game& game) override;
    void cleanup() override;
    void handleEvents(Game& game) override;
    void update(Game& game) override;
    void render(Game& game) override;
};


===== C:\Universidad\estructuras-de-datos\include\ui\PantallaEditarReceta.hpp =====


===== C:\Universidad\estructuras-de-datos\include\ui\PantallaEliminarReceta.hpp =====
#pragma once
#include "ui/GameState.hpp"
#include "ui/Boton.hpp"
#include "ui/CajaDeTexto.hpp"
#include <SDL3/SDL.h>
#include <SDL3_ttf/SDL_ttf.h>

class Game; // Forward declaration

class PantallaEliminarReceta : public GameState {
private:
    TTF_Font* fuenteTitulo;
    TTF_Font* fuenteInputs;

    SDL_Texture* texturaTitulo;
    SDL_FRect rectTitulo;

    CajaDeTexto* inputNombre;
    
    Boton* btnEliminar;
    Boton* btnCancelar;

    void eliminarReceta(Game& game);

public:
    PantallaEliminarReceta();
    virtual ~PantallaEliminarReceta();

    void init(Game& game) override;
    void cleanup() override;
    void handleEvents(Game& game) override;
    void update(Game& game) override;
    void render(Game& game) override;
};


===== C:\Universidad\estructuras-de-datos\include\ui\PantallaGestionArchivos.hpp =====
#pragma once
#include "ui/GameState.hpp"
#include "ui/Boton.hpp"
#include "ui/CajaDeTexto.hpp"
#include <vector>
#include <string>
#include <filesystem>
#include <future>
#include <chrono>
#include <SDL3/SDL.h>
#include <SDL3_ttf/SDL_ttf.h>

class PantallaGestionArchivos : public GameState {
private:
    TTF_Font* fuenteTitulo;
    TTF_Font* fuenteLista;
    TTF_Font* fuenteSettings;
    TTF_Font* fuenteCargando; // ?? NUEVO
    SDL_Texture* texTitulo;
    SDL_FRect rectTitulo;

    bool modoGuardar;

    struct BotonArchivo {
        Boton* btn;
        SDL_Texture* label;
        SDL_FRect rectLabel;
        std::string nombreArchivo;
    };
    std::vector<BotonArchivo> listaBotonesArchivos;

    Boton* btnNuevoArchivo; 
    CajaDeTexto* inputNuevoArchivo;
    Boton* btnCargarTest;
    Boton* btnVolver;
    
    Boton* btnSeparador;
    SDL_Texture* texSeparador;
    std::string separadorActual;

    // ?? NUEVO: Estado de carga asíncrona
    bool cargandoDatos;
    std::future<void> tareaIO;
    std::string rutaPendiente;
    bool modoGuardarPendiente;
    SDL_Texture* texCargando;
    SDL_FRect rectCargando;

    void escanearDirectorio(SDL_Renderer* renderer);
    void seleccionarArchivo(Game& game, const std::string& nombre);
    void crearYSeleccionar(Game& game);
    void cargarDatosPrueba(Game& game);
    void actualizarSeparador(SDL_Renderer* renderer);

public:
    PantallaGestionArchivos(bool esModoGuardar);
    ~PantallaGestionArchivos();

    void init(Game& game) override;
    void cleanup() override;
    void handleEvents(Game& game) override;
    void update(Game& game) override;
    void render(Game& game) override;
};


===== C:\Universidad\estructuras-de-datos\include\ui\PantallaImagenCompleta.hpp =====
#pragma once
#include "ui/GameState.hpp"
#include <SDL3/SDL.h>
#include <string>

class PantallaImagenCompleta : public GameState {
private:
    std::string rutaImagen;
    SDL_Texture* texturaImagen;
    SDL_FRect rectImagen;

public:
    PantallaImagenCompleta(const std::string& ruta);
    ~PantallaImagenCompleta();

    void init(Game& game) override;
    void cleanup() override;
    void handleEvents(Game& game) override;
    void update(Game& game) override;
    void render(Game& game) override;
};


===== C:\Universidad\estructuras-de-datos\include\ui\PantallaMenuPrincipal.hpp =====
#pragma once
#include "ui/GameState.hpp"
#include "ui/Boton.hpp"
#include <SDL3/SDL.h>
#include <SDL3_ttf/SDL_ttf.h>

class PantallaMenuPrincipal : public GameState {
private:
    TTF_Font* fuenteTitulo;
    SDL_Texture* texturaTitulo;
    SDL_FRect rectTitulo;

    Boton* btnAgregar;
    Boton* btnVer;
    Boton* btnSalir;
    Boton* btnHerramientas;

public:
    PantallaMenuPrincipal();
    ~PantallaMenuPrincipal();

    void init(Game& game) override;
    void cleanup() override;

    void handleEvents(Game& game) override;
    void update(Game& game) override;
    void render(Game& game) override;
};


===== C:\Universidad\estructuras-de-datos\include\ui\PantallaOrdenarRecetas.hpp =====


===== C:\Universidad\estructuras-de-datos\include\ui\PantallaSalida.hpp =====
#pragma once
#include "ui/GameState.hpp"
#include <SDL3/SDL.h>
#include <SDL3_ttf/SDL_ttf.h>
#include <string>

class PantallaSalida : public GameState {
private:
    TTF_Font* fuente;
    SDL_Texture* textoBase;
    SDL_FRect rectTexto;
    
    float tiempoAcumulado;
    int puntos; // 0, 1, 2, 3
    int ciclosCompletados;
    Uint64 ultimoTick;

public:
    PantallaSalida();
    ~PantallaSalida();

    void init(Game& game) override;
    void cleanup() override;
    void handleEvents(Game& game) override;
    void update(Game& game) override;
    void render(Game& game) override;
};


===== C:\Universidad\estructuras-de-datos\include\ui\PantallaVisualizarRecetas.hpp =====
#pragma once
#include "ui/GameState.hpp"
#include "ui/Boton.hpp"
#include "ui/CajaDeTexto.hpp"
#include "ui/PantallaGestionArchivos.hpp" // NUEVO
#include <SDL3/SDL.h>
#include <SDL3_ttf/SDL_ttf.h>
#include <vector>
#include <string>

struct ItemLista {
    SDL_Texture* textura;
    SDL_Texture* texMiniatura;
    SDL_FRect rect;
    int indiceOriginal;
    SDL_FRect rectOjo;
    SDL_FRect rectEditar; // NUEVO
    SDL_FRect rectBasura;
};

class PantallaVisualizarRecetas : public GameState {
private:
    TTF_Font* fuenteTitulo;
    TTF_Font* fuenteLista;
    TTF_Font* fuenteUI; 
    
    SDL_Texture* texturaTitulo;
    SDL_FRect rectTitulo;
    
    CajaDeTexto* inputBusqueda;
    Boton* btnBuscar;
    Boton* btnReset;

    Boton* btnOrdNombre;
    Boton* btnOrdTiempo;
    Boton* btnOrdCategoria;
    Boton* btnOrdAutor;
    
    Boton* btnCargar;
    Boton* btnGuardar;
    Boton* btnEliminarTodo;
    
    // Boton* btnIrAEliminar; // ELIMINADO, ahora es por fila

    SDL_Texture* texIconoOjo;
    SDL_Texture* texIconoBasura;
    SDL_Texture* texIconoEditar; // NUEVO

    SDL_Texture* texLblNombre; SDL_FRect rLblNombre;
    SDL_Texture* texLblTiempo; SDL_FRect rLblTiempo;
    SDL_Texture* texLblCat;    SDL_FRect rLblCat;
    SDL_Texture* texLblAut;    SDL_FRect rLblAut;
    SDL_Texture* texLblCargar; SDL_FRect rLblCargar;
    SDL_Texture* texLblGuardar; SDL_FRect rLblGuardar;
    SDL_Texture* texLblDelAll; SDL_FRect rLblDelAll;

    Boton* btnVolver;
    std::vector<ItemLista> itemsLista;
    std::string filtroNombre; 

    void generarCacheListado(Game& game);

public:
    PantallaVisualizarRecetas();
    ~PantallaVisualizarRecetas();

    void init(Game& game) override;
    void cleanup() override;
    void handleEvents(Game& game) override;
    void update(Game& game) override;
    void render(Game& game) override;
};


===== C:\Universidad\estructuras-de-datos\include\utils\ConvertidoresFormatos.hpp =====
#pragma once
#include <string>

class ConvertidoresFormatos {
public:
    static std::string enteroAstring(int numero);
    static std::string floatAstring(float numero, int decimales);
    static std::string boolAtexto(bool valor);
    
    static int stringAentero(const std::string& texto);
    static float stringAfloat(const std::string& texto);
    
    static std::string limpiarEspacios(const std::string& texto);
    static std::string convertirAMayusculas(const std::string& texto);
    
    static std::string padearIzquierda(const std::string& texto, int ancho, char relleno);
    static std::string padearDerecha(const std::string& texto, int ancho, char relleno);
};


===== C:\Universidad\estructuras-de-datos\include\utils\RenderizadorTextos.hpp =====
#pragma once
#include <SDL3/SDL.h>
#include <SDL3_ttf/SDL_ttf.h>
#include <string>

class RenderizadorTextos {
public:
    static SDL_Texture* renderizarTexto(SDL_Renderer* renderer, TTF_Font* fuente, const std::string& texto, SDL_Color color);
};


===== C:\Universidad\estructuras-de-datos\include\utils\ValidadorEntradas.hpp =====
#pragma once
#include <string>
#include <regex>
#include <algorithm>
#include <cctype>

class ValidadorEntradas {
private:
    static const std::string REGEX_EMAIL;
    static const std::string REGEX_NOMBRE;
    static const std::string REGEX_NUMERO_ENTERO;
    static const std::string REGEX_NUMERO_DECIMAL;

    ValidadorEntradas() = delete;

public:

    static bool verificarQueNoEsteVacio(const std::string& entrada);
    static bool verificarSiEsNombreValido(const std::string& nombre);
    static bool verificarSiEsNumeroEnteroPositivo(const std::string& entrada);
    static bool verificarSiEsNumeroDecimalPositivo(const std::string& entrada);
    static bool verificarSiEstaEnRango(int valor, int minimo, int maximo);
    static bool verificarLongitudString( const std::string& entrada, size_t longitudMinima, size_t longitudMaxima
    );
    /*
    bool ValidadorEntradas::verificarLongitudString(
    const std::string& entrada,
    size_t longitudMinima,  // Cambiar int por size_t
    size_t longitudMaxima   // Cambiar int por size_t
) {
    return entrada.length() >= longitudMinima && entrada.length() <= longitudMaxima;
}
    */

    static bool verificarSiEsEmailValido(const std::string& email);
    static bool verificarSiEsRutaArchivoValida(const std::string& ruta);

    static std::string limpiarYnormalizarEntrada(const std::string& entrada);
    static std::string convertirAminusculas(const std::string& texto);
    static std::string convertirAmayusculas(const std::string& texto);
    static std::string capitalizarPrimeraLetra(const std::string& texto);

    static bool verificarSiEsOpcionMenuValida( const std::string& opcion, const std::string& opcionesValidas);
};

namespace MensajesError {
    const std::string ENTRADA_VACIA = "La entrada no puede estar vacÃ­a";
    const std::string NOMBRE_INVALIDO = "Nombre invÃ¡lido: solo letras y espacios permitidos";
    const std::string NUMERO_INVALIDO = "NÃºmero invÃ¡lido: debe ser un nÃºmero vÃ¡lido";
    const std::string FUERA_RANGO = "El valor estÃ¡ fuera del rango permitido";
    const std::string LONGITUD_INVALIDA = "La longitud de la entrada no es vÃ¡lida";
    const std::string EMAIL_INVALIDO = "Email invÃ¡lido: formato no reconocido";
    const std::string OPCION_INVALIDA = "OpciÃ³n invÃ¡lida: selecciona una opciÃ³n vÃ¡lida";
}


===== C:\Universidad\estructuras-de-datos\include\DatosPruebaRecetario.hpp =====
#pragma once
#include "entities/Receta.hpp"
#include "datastructures/templates/ListaDoblementeLigada.hpp"

class DatosPruebaRecetario {
public:

    static ListaDoblementeLigada<Receta> obtenerRecetasDeEjemplo();

private:

    static Receta crearChilaquilesVerdes();
    static Receta crearMolePolano();    
    static Receta crearPozoleRojo();
    static Receta crearTamalesDeRajas();
    static Receta crearEnchaladasSuizas();
    static Receta crearCarneAsada();
    static Receta crearQuesadillasFlordeCalabazo();
    static Receta crearChilesRellenos();
    static Receta crearCochinitaPibil();    
    static Receta crearPastelTresLeches();
    static Receta crearSopaDeTortilla();
    static Receta crearFajitasDePollo();
};



===== C:\Universidad\estructuras-de-datos\include\Game.hpp =====
#pragma once

#include <SDL3/SDL.h>
#include <SDL3_image/SDL_image.h> 
#include <SDL3_ttf/SDL_ttf.h>  
#include <string>
#include "datastructures/templates/PilaDinamica.hpp"
#include "datastructures/managers/ManejadorRecetas.hpp"
#include "ui/GameState.hpp"

class GameState; 

class Game {
private:
    SDL_Window* ventana;
    SDL_Renderer* renderer;

    bool estaCorriendo;
    PilaDinamica<GameState*> estadosJuego; 
    
    ManejadorRecetas manejadorRecetas;
    const std::string RUTA_ARCHIVO_RECETAS = "assets/data/recetario.dat";

    void inicializarSDL();
    void cargarDatos();
    void limpiar();
    
    void procesarEventos();
    void actualizar();
    void dibujar();

public:
    Game();
    ~Game();

    void run();

    void pushEstado(GameState* estado);
    void popEstado();
    void cambiarEstado(GameState* estado);

    SDL_Renderer* getRenderer() { return renderer; }
    SDL_Window* getWindow() { return ventana; } // <--- NUEVO GETTER IMPORTANTE
    ManejadorRecetas& getManejadorRecetas() { return manejadorRecetas; }
    bool estaCorriendoApp() const { return estaCorriendo; }
    
    void setEstaCorriendo(bool valor) { estaCorriendo = valor; }
};


===== C:\Universidad\estructuras-de-datos\src\datastructures\implementations\ColaDinamica.cpp =====


===== C:\Universidad\estructuras-de-datos\src\datastructures\implementations\NodoCircularDoble.cpp =====


===== C:\Universidad\estructuras-de-datos\src\datastructures\implementations\NodoSimplementeLigado.cpp =====


===== C:\Universidad\estructuras-de-datos\src\datastructures\implementations\PilaDinamica.cpp =====


===== C:\Universidad\estructuras-de-datos\src\datastructures\implementations\PilaEstatica.cpp =====


===== C:\Universidad\estructuras-de-datos\src\datastructures\managers\ManejadorIngredientes.cpp =====


===== C:\Universidad\estructuras-de-datos\src\datastructures\managers\ManejadorRecetas.cpp =====
#include "datastructures/managers/ManejadorRecetas.hpp"
#include <stdexcept>
#include <fstream>
#include <limits>
#include <sstream>
#include <iostream>
#include <future>
#include <chrono>

ManejadorRecetas::ManejadorRecetas() {}
ManejadorRecetas::~ManejadorRecetas() {}

// --- AUXILIARES ---

int ManejadorRecetas::encontrarIndiceRecetaPorNombre(const std::string& nombreBuscado) const {
    for (int i = 0; i < recetasAlmacenadas.obtenerCantidadElementos(); ++i) {
        if (recetasAlmacenadas.obtenerEnPosicion(i).obtenerNombrePlatillo() == nombreBuscado) {
            return i;
        }
    }
    return -1;
}

// --- CRUD ---

void ManejadorRecetas::agregarRecetaNueva(const Receta& recetaAinsertar) {
    if (verificarSiRecetaExiste(recetaAinsertar.obtenerNombrePlatillo())) {
        throw std::runtime_error("Ya existe: " + recetaAinsertar.obtenerNombrePlatillo());
    }
    recetasAlmacenadas.agregarAlFinal(recetaAinsertar);
}

Receta& ManejadorRecetas::obtenerRecetaPorNombre(const std::string& nombreBuscado) {
    int idx = encontrarIndiceRecetaPorNombre(nombreBuscado);
    if (idx == -1) throw std::runtime_error("No encontrada: " + nombreBuscado);
    return recetasAlmacenadas.obtenerEnPosicion(idx);
}

const Receta& ManejadorRecetas::obtenerRecetaPorNombreConstante(const std::string& nombreBuscado) const {
    int idx = encontrarIndiceRecetaPorNombre(nombreBuscado);
    if (idx == -1) throw std::runtime_error("No encontrada: " + nombreBuscado);
    return recetasAlmacenadas.obtenerEnPosicion(idx);
}

void ManejadorRecetas::eliminarRecetaPorNombre(const std::string& nombreAeliminar) {
    int idx = encontrarIndiceRecetaPorNombre(nombreAeliminar);
    if (idx == -1) throw std::runtime_error("No encontrada para eliminar: " + nombreAeliminar);
    recetasAlmacenadas.eliminarEnPosicion(idx);
}

void ManejadorRecetas::eliminarTodasLasRecetas() {
    recetasAlmacenadas.limpiarLista();
}

bool ManejadorRecetas::verificarSiRecetaExiste(const std::string& nombreReceta) const {
    return encontrarIndiceRecetaPorNombre(nombreReceta) != -1;
}

// --- ORDENAMIENTO (QuickSort Recursivo) ---

int ManejadorRecetas::particion(ListaDoblementeLigada<Receta>& lista, int izquierda, int derecha, int (*comparador)(const Receta&, const Receta&)) {
    Receta pivote = lista.obtenerEnPosicion(derecha);
    int i = (izquierda - 1);
    for (int j = izquierda; j <= derecha - 1; j++) {
        if (comparador(lista.obtenerEnPosicion(j), pivote) < 0) {
            i++;
            lista.intercambiarDatos(i, j);
        }
    }
    lista.intercambiarDatos(i + 1, derecha);
    return (i + 1);
}

void ManejadorRecetas::quickSortRecursivo(ListaDoblementeLigada<Receta>& lista, int izquierda, int derecha, int (*comparador)(const Receta&, const Receta&)) {
    if (izquierda < derecha) {
        int pi = particion(lista, izquierda, derecha, comparador);
        quickSortRecursivo(lista, izquierda, pi - 1, comparador);
        quickSortRecursivo(lista, pi + 1, derecha, comparador);
    }
}

void ManejadorRecetas::ordenarRecetasPorNombre() {
    if (recetasAlmacenadas.obtenerCantidadElementos() > 1)
        quickSortRecursivo(recetasAlmacenadas, 0, recetasAlmacenadas.obtenerCantidadElementos() - 1, Receta::compararPorNombre);
}
void ManejadorRecetas::ordenarRecetasPorTiempoPreparacion() {
    if (recetasAlmacenadas.obtenerCantidadElementos() > 1)
        quickSortRecursivo(recetasAlmacenadas, 0, recetasAlmacenadas.obtenerCantidadElementos() - 1, Receta::compararPorTiempoPreparacion);
}
void ManejadorRecetas::ordenarRecetasPorCategoria() {
    if (recetasAlmacenadas.obtenerCantidadElementos() > 1)
        quickSortRecursivo(recetasAlmacenadas, 0, recetasAlmacenadas.obtenerCantidadElementos() - 1, Receta::compararPorCategoria);
}
void ManejadorRecetas::ordenarRecetasPorAutor() {
    if (recetasAlmacenadas.obtenerCantidadElementos() > 1)
        quickSortRecursivo(recetasAlmacenadas, 0, recetasAlmacenadas.obtenerCantidadElementos() - 1, Receta::compararPorAutor);
}

// --- BÚSQUEDA ---

Receta* ManejadorRecetas::buscarRecetaBinariaPorNombre(const std::string& nombreBuscado) {
    ordenarRecetasPorNombre();
    int izquierda = 0;
    int derecha = recetasAlmacenadas.obtenerCantidadElementos() - 1;
    while (izquierda <= derecha) {
        int medio = izquierda + (derecha - izquierda) / 2;
        Receta& recetaMedio = recetasAlmacenadas.obtenerEnPosicion(medio);
        std::string nombreMedio = recetaMedio.obtenerNombrePlatillo();
        if (nombreMedio == nombreBuscado) return &recetaMedio;
        if (nombreMedio < nombreBuscado) izquierda = medio + 1;
        else derecha = medio - 1;
    }
    return nullptr;
}


// --- PERSISTENCIA (I/O) ---

void ManejadorRecetas::guardarRecetasAarchivo(const std::string& rutaArchivo) {
    std::ofstream archivoSalida(rutaArchivo);
    if (!archivoSalida.is_open()) throw std::runtime_error("Error IO guardar: " + rutaArchivo);

    int cant = recetasAlmacenadas.obtenerCantidadElementos();
    archivoSalida << cant << std::endl;
    for (int i = 0; i < cant; ++i) {
        archivoSalida << recetasAlmacenadas.obtenerEnPosicion(i);
    }
    archivoSalida.close();
}

void ManejadorRecetas::cargarRecetasDesdeArchivo(const std::string& rutaArchivo) {
    std::ifstream archivoEntrada(rutaArchivo);
    if (!archivoEntrada.is_open()) {
        std::cerr << "[I/O] No se encontró el archivo: " << rutaArchivo << std::endl;
        return;
    }
    if (archivoEntrada.peek() == std::ifstream::traits_type::eof()) return;

    int cantidad = 0;
    archivoEntrada >> cantidad;
    
    if (archivoEntrada.fail() || cantidad < 0 || cantidad > 10000) {
        std::cerr << "[ALERTA] Archivo corrupto (Cantidad invalida). Abortando carga." << std::endl;
        archivoEntrada.clear(); 
        return;
    }

    eliminarTodasLasRecetas();
    archivoEntrada.ignore(std::numeric_limits<std::streamsize>::max(), '\n');

    for (int i = 0; i < cantidad; ++i) {
        Receta r;
        
        // Blindaje de flujo CRÍTICO
        if (archivoEntrada.eof() || archivoEntrada.bad()) { 
            std::cerr << "[BLINDAJE] EOF o Bad stream detectado en Receta #" << i + 1 << ". Deteniendo carga." << std::endl;
            break; 
        }
        
        archivoEntrada >> r;
        
        // Chequeo de integridad después de la lectura
        if (archivoEntrada.fail() || r.obtenerNombrePlatillo().empty() || r.obtenerNombrePlatillo() == "Sin nombre") {
             std::cerr << "[ERROR I/O] Datos corruptos/faltantes en Receta #" << i + 1 << ". Deteniendo lectura." << std::endl;
             archivoEntrada.clear();
             break;
        }
        
        recetasAlmacenadas.agregarAlFinal(r);
    }
    archivoEntrada.close();
}

std::string ManejadorRecetas::obtenerEstadisticasRecetario() const {
    return "Total Recetas: " + std::to_string(obtenerCantidadRecetas());
}



// ?? NUEVO MÉTODO: Validación rápida de archivos
bool ManejadorRecetas::archivoEsValido(const std::string& rutaArchivo) {
    std::ifstream archivo(rutaArchivo);
    if (!archivo.is_open()) return false;
    
    int cantidad = 0;
    archivo >> cantidad;
    
    if (archivo.fail() || cantidad < 0 || cantidad > 10000) {
        return false;
    }
    
    return true;
}


===== C:\Universidad\estructuras-de-datos\src\entities\Categoria.cpp =====
#include "entities/Categoria.hpp"

std::string categoriaATexto(Categoria categoria) {
    switch (categoria) {
        case Categoria::DESAYUNO: return "Desayuno";
        case Categoria::COMIDA:   return "Comida";
        case Categoria::CENA:     return "Cena";
        case Categoria::NAVIDENO: return "Navideno";
        default:                  return "Sin Categorizar";
    }
}


===== C:\Universidad\estructuras-de-datos\src\entities\Ingrediente.cpp =====
#include "entities/Ingrediente.hpp"

Ingrediente::Ingrediente() : 
    nombreIngrediente(""), 
    cantidadIngrediente("0"), 
    unidadMedida("") {}

Ingrediente::Ingrediente(const std::string& nombre, const std::string& cantidad, const std::string& unidad)
    : nombreIngrediente(nombre), 
    cantidadIngrediente(cantidad), 
    unidadMedida(unidad) {}

Ingrediente::Ingrediente(const Ingrediente& otro)
    : nombreIngrediente(otro.nombreIngrediente),
    cantidadIngrediente(otro.cantidadIngrediente),
    unidadMedida(otro.unidadMedida) {}

Ingrediente::Ingrediente(Ingrediente&& otro) noexcept
    : nombreIngrediente(std::move(otro.nombreIngrediente)),
    cantidadIngrediente(std::move(otro.cantidadIngrediente)),
    unidadMedida(std::move(otro.unidadMedida)) {}

Ingrediente& Ingrediente::operator=(const Ingrediente& otro) {
    if (this != &otro) {
        nombreIngrediente = otro.nombreIngrediente;
        cantidadIngrediente = otro.cantidadIngrediente;
        unidadMedida = otro.unidadMedida;
    }
    return *this;
}

Ingrediente& Ingrediente::operator = (Ingrediente&& otro) noexcept {
    if (this != &otro) {
        nombreIngrediente = std::move(otro.nombreIngrediente);
        cantidadIngrediente = std::move(otro.cantidadIngrediente);
        unidadMedida = std::move(otro.unidadMedida);
    }
    return *this;
}

bool Ingrediente::operator == (const Ingrediente& otro) const {
    return nombreIngrediente == otro.nombreIngrediente;
}

bool Ingrediente::operator < (const Ingrediente& otro) const {
    return nombreIngrediente < otro.nombreIngrediente;
}

int Ingrediente::compararPorNombre(const Ingrediente& ing1, const Ingrediente& ing2) {
    if (ing1.nombreIngrediente < ing2.nombreIngrediente) return -1;
    if (ing1.nombreIngrediente > ing2.nombreIngrediente) return 1;
    return 0;
}
std::string Ingrediente::toString() const {
    return nombreIngrediente;
}

std::string Ingrediente::obtenerRepresentacionFormateada() const {
    return cantidadIngrediente + " " + unidadMedida + " de " + nombreIngrediente;
}

std::ostream& operator<<(std::ostream& salida, const Ingrediente& ing) {
    salida << ing.nombreIngrediente << "\n" << ing.cantidadIngrediente << "\n" << ing.unidadMedida << "\n";
    return salida;
}

// CORRECCIÓN: Usar entrada sin std::ws y getline consecutivas
std::istream& operator>>(std::istream& entrada, Ingrediente& ing) {
    // Usamos std::ws para consumir espacios en blanco iniciales antes del primer getline
    std::getline(entrada >> std::ws, ing.nombreIngrediente); 
    std::getline(entrada, ing.cantidadIngrediente);
    std::getline(entrada, ing.unidadMedida);
    
    // Si falla la lectura de cualquiera de las lineas, el flag fail se activa
    // Si la lectura de cantidad es un newline vacio, esto evita el crash
    
    return entrada;
}


===== C:\Universidad\estructuras-de-datos\src\entities\Nombre.cpp =====

#include "entities/Nombre.hpp"

Nombre::Nombre() 
    : primerNombre(""), apellidoPrimero(""), apellidoSegundo("") {}

Nombre::Nombre(const std::string& primerNombreIngreso, 
    const std::string& apellidoUno, 
    const std::string& apellidoDos)
    : primerNombre(primerNombreIngreso), apellidoPrimero(apellidoUno), apellidoSegundo(apellidoDos) {}

Nombre::Nombre(const Nombre& otroNombre)
    : primerNombre(otroNombre.primerNombre), apellidoPrimero(otroNombre.apellidoPrimero), apellidoSegundo(otroNombre.apellidoSegundo) {}

Nombre::Nombre(Nombre&& otroNombre) noexcept
    : primerNombre(std::move(otroNombre.primerNombre)), apellidoPrimero(std::move(otroNombre.apellidoPrimero)),apellidoSegundo(std::move(otroNombre.apellidoSegundo)) {}

Nombre& Nombre::operator=(const Nombre& otroNombre) {
    if (this != &otroNombre) {
        primerNombre = otroNombre.primerNombre;
        apellidoPrimero = otroNombre.apellidoPrimero;
        apellidoSegundo = otroNombre.apellidoSegundo;
    }
    return *this;
}

Nombre& Nombre::operator=(Nombre&& otroNombre) noexcept {
    if (this != &otroNombre) {
        primerNombre = std::move(otroNombre.primerNombre);
        apellidoPrimero = std::move(otroNombre.apellidoPrimero);
        apellidoSegundo = std::move(otroNombre.apellidoSegundo);
    }
    return *this;
}


bool Nombre::operator==(const Nombre& otroNombre) const {
    return primerNombre == otroNombre.primerNombre 
    && apellidoPrimero == otroNombre.apellidoPrimero 
    && apellidoSegundo == otroNombre.apellidoSegundo;
}

bool Nombre::operator<(const Nombre& otroNombre) const {
    if (apellidoPrimero != otroNombre.apellidoPrimero) {
        return apellidoPrimero < otroNombre.apellidoPrimero;
    }
    if (apellidoSegundo != otroNombre.apellidoSegundo) {
        return apellidoSegundo < otroNombre.apellidoSegundo;
    }
    return primerNombre < otroNombre.primerNombre;
}

void Nombre::establecerPrimerNombre(const std::string& nombre) {
    primerNombre = nombre;
}

void Nombre::establecerApellidos(const std::string& apl1, const std::string& apl2) {
    apellidoPrimero = apl1;
    apellidoSegundo = apl2;
}
std::string Nombre::obtenerNombreCompleto() const {
    std::string completo = primerNombre + " " + apellidoPrimero;
    if (!apellidoSegundo.empty()) {
        completo += " " + apellidoSegundo;
    }
    return completo;
}

std::string Nombre::obtenerIniciales() const {
    std::string iniciales = "";
    if (!primerNombre.empty()) iniciales += primerNombre[0];
    if (!apellidoPrimero.empty()) iniciales += apellidoPrimero[0];
    if (!apellidoSegundo.empty()) iniciales += apellidoSegundo[0];
    return iniciales;
}

std::string Nombre::toString() const {
    return obtenerNombreCompleto();
}

void Nombre::validarYnormalizarNombre(std::string& texto) {
    // TODO: Implementar lÃ³gica de validaciÃ³n (quitar espacios, mayÃºsculas)
}

std::ostream& operator<<(std::ostream& salida, const Nombre& nombre) {
    salida << nombre.primerNombre << "\n" 
        << nombre.apellidoPrimero << "\n" 
        << nombre.apellidoSegundo;
    return salida;
}

std::istream& operator>>(std::istream& entrada, Nombre& nombre) {
    std::getline(entrada >> std::ws, nombre.primerNombre);
    std::getline(entrada, nombre.apellidoPrimero);
    std::getline(entrada, nombre.apellidoSegundo);
    return entrada;
}


===== C:\Universidad\estructuras-de-datos\src\entities\Receta.cpp =====
#include "entities/Receta.hpp"
#include "utils/ConvertidoresFormatos.hpp"
#include <sstream>
#include <limits> // Para std::numeric_limits

Receta::Receta()
    : nombrePlatillo("Sin nombre"),
      autorReceta(),
      categoriaReceta(Categoria::SIN_CATEGORIZAR),
      tiempoPreparacionMinutos(0),
      procedimientoPasos("Sin procedimiento"),
      rutaImagenPlatillo("") {
}

Receta::Receta(const std::string& nombrePlatillo_,
            const Nombre& autor,
            const Categoria& categoria,
            int tiempoMinutos,
            
const std::string& procedimiento)
    : nombrePlatillo(nombrePlatillo_),
        autorReceta(autor),
        categoriaReceta(categoria),
        tiempoPreparacionMinutos(tiempoMinutos),
        procedimientoPasos(procedimiento),
        rutaImagenPlatillo("") {
}

Receta::Receta(const Receta& otraReceta)
    : nombrePlatillo(otraReceta.nombrePlatillo),
        autorReceta(otraReceta.autorReceta),
        categoriaReceta(otraReceta.categoriaReceta),
        tiempoPreparacionMinutos(otraReceta.tiempoPreparacionMinutos),
        procedimientoPasos(otraReceta.procedimientoPasos),
        ingredientesListaOrdenada(otraReceta.ingredientesListaOrdenada),
     
    rutaImagenPlatillo(otraReceta.rutaImagenPlatillo) {
}

Receta::Receta(Receta&& otraReceta) noexcept //c++11
    : nombrePlatillo(std::move(otraReceta.nombrePlatillo)),
    autorReceta(std::move(otraReceta.autorReceta)),
    categoriaReceta(otraReceta.categoriaReceta),
    tiempoPreparacionMinutos(otraReceta.tiempoPreparacionMinutos),
    procedimientoPasos(std::move(otraReceta.procedimientoPasos)),
    ingredientesListaOrdenada(std::move(otraReceta.ingredientesListaOrdenada)),
    rutaImagenPlatillo(std::move(otraReceta.rutaImagenPlatillo)) {
}

Receta& Receta::operator=(const Receta& otraReceta) {
    if (this != &otraReceta) {
        nombrePlatillo = otraReceta.nombrePlatillo;
        autorReceta = otraReceta.autorReceta;
        categoriaReceta = otraReceta.categoriaReceta;
        tiempoPreparacionMinutos = otraReceta.tiempoPreparacionMinutos;
        procedimientoPasos = otraReceta.procedimientoPasos;
        ingredientesListaOrdenada = otraReceta.ingredientesListaOrdenada;
        rutaImagenPlatillo = otraReceta.rutaImagenPlatillo;
    }
    return *this;
}

Receta& Receta::operator=(Receta&& otraReceta) noexcept {
    if (this != &otraReceta) {
        nombrePlatillo = std::move(otraReceta.nombrePlatillo);
        autorReceta = std::move(otraReceta.autorReceta);
        categoriaReceta = otraReceta.categoriaReceta;
        tiempoPreparacionMinutos = otraReceta.tiempoPreparacionMinutos;
        procedimientoPasos = std::move(otraReceta.procedimientoPasos);
        ingredientesListaOrdenada = std::move(otraReceta.ingredientesListaOrdenada);
        rutaImagenPlatillo = std::move(otraReceta.rutaImagenPlatillo);
    }
    return *this;
}


bool Receta::operator==(const Receta& otraReceta) const {
    return nombrePlatillo == otraReceta.nombrePlatillo;
}

bool Receta::operator<(const Receta& otraReceta) const {
    return nombrePlatillo < otraReceta.nombrePlatillo;
}

int Receta::compararPorNombre(const Receta& rec1, const Receta& rec2) {
    if (rec1.nombrePlatillo < rec2.nombrePlatillo) return -1;
    if (rec1.nombrePlatillo > rec2.nombrePlatillo) return 1;
    return 0;
}

int Receta::compararPorTiempoPreparacion(const Receta& rec1, const Receta& rec2) {
    if (rec1.tiempoPreparacionMinutos < rec2.tiempoPreparacionMinutos) return -1;
    if (rec1.tiempoPreparacionMinutos > rec2.tiempoPreparacionMinutos) return 1;
    return 0;
}

int Receta::compararPorCategoria(const Receta& rec1, const Receta& rec2) {
    int cat1 = static_cast<int>(rec1.categoriaReceta);
    int cat2 = static_cast<int>(rec2.categoriaReceta);
    
    if (cat1 < cat2) return -1;
    if (cat1 > cat2) return 1;
    return 0;
}

int Receta::compararPorAutor(const Receta& rec1, const Receta& rec2) {
    if (rec1.autorReceta < rec2.autorReceta) return -1;
    if (rec2.autorReceta < rec1.autorReceta) return 1;
    return 0;
}


void Receta::agregarIngredienteOrdenado(const Ingrediente& ingrediente) {
    if (ingredientesListaOrdenada.obtenerCantidadElementos() == 0) {
        ingredientesListaOrdenada.agregarAlFinal(ingrediente);
        return;
    }
    for (int i = 0; i < ingredientesListaOrdenada.obtenerCantidadElementos(); ++i) {
        if (ingrediente.obtenerNombre() < 
            ingredientesListaOrdenada.obtenerEnPosicion(i).obtenerNombre()) {
            ingredientesListaOrdenada.agregarEnPosicion(i, ingrediente);
            return;
        }
    } ingredientesListaOrdenada.agregarAlFinal(ingrediente);
}

void Receta::eliminarIngredientePorNombre(const std::string& nombreIngrediente) {
    for (int i = 0; i < ingredientesListaOrdenada.obtenerCantidadElementos(); ++i) {
        if (ingredientesListaOrdenada.obtenerEnPosicion(i).obtenerNombre() == nombreIngrediente) {
            ingredientesListaOrdenada.eliminarEnPosicion(i);
            return;
        }
    } throw std::runtime_error("Ingrediente no encontrado: " + nombreIngrediente);
}

void Receta::eliminarTodosLosIngredientes() {
    ingredientesListaOrdenada.limpiarLista();
}

bool Receta::verificarSiIngredienteExiste(const std::string& nombreBuscado) const {
    for (int i = 0; i < ingredientesListaOrdenada.obtenerCantidadElementos(); ++i) {
        if (ingredientesListaOrdenada.obtenerEnPosicion(i).obtenerNombre() == nombreBuscado) {
            return true;
        }
    }
    return false;
}

Ingrediente& Receta::obtenerIngredientePorNombre(const std::string& nombreBuscado) {
    for (int i = 0; i < ingredientesListaOrdenada.obtenerCantidadElementos(); ++i) {
        if (ingredientesListaOrdenada.obtenerEnPosicion(i).obtenerNombre() == nombreBuscado) {
            return ingredientesListaOrdenada.obtenerEnPosicion(i);
        }
    }
    throw std::runtime_error("Ingrediente no encontrado: " + nombreBuscado);
}

void Receta::modificarCantidadIngrediente(const std::string& nombreIngrediente, const std::string& nuevaCantidad) {
    Ingrediente& ingredienteAmodificar = obtenerIngredientePorNombre(nombreIngrediente);
    ingredienteAmodificar.establecerCantidad(nuevaCantidad);
}

std::string Receta::toString() const {
    return nombrePlatillo;
}

std::string Receta::obtenerResumenCorto() const {
    std::stringstream resumen;
    resumen << ">>> " << nombrePlatillo << " <<<\n";
    resumen << "Autor: " << autorReceta.obtenerNombreCompleto() << "\n";
    resumen << "Categoriaa: " << categoriaATexto(categoriaReceta) << "\n";
    resumen << "Tiempo: " << tiempoPreparacionMinutos << " minutos\n";
    resumen << "Igredientes: " << ingredientesListaOrdenada.obtenerCantidadElementos() << "\n";
    return resumen.str();
}

std::string Receta::obtenerDetalleCompleto() const {
    std::stringstream detalle;
    
    detalle << "+----------------------------------------+\n";
    detalle << "¦  RECETA: " << nombrePlatillo << "\n";
    detalle << "+----------------------------------------+\n";
    detalle << "Autor: " << autorReceta.obtenerNombreCompleto() << "\n";
    detalle << "Categoría: " << categoriaATexto(categoriaReceta) << "\n";
    detalle << "Tiempo de Preparación: " << tiempoPreparacionMinutos << " minutos\n\n";
    
    detalle << "--- INGREDIENTES ---\n";
    for (int i = 0; i < ingredientesListaOrdenada.obtenerCantidadElementos(); ++i) {
        const Ingrediente& ing = ingredientesListaOrdenada.obtenerEnPosicion(i);
        detalle << "  • " << ing.obtenerRepresentacionFormateada() << "\n";
    }
    
    detalle << "\n--- PROCEDIMIENTO ---\n";
    detalle << procedimientoPasos << "\n";
    
    return detalle.str();
}

std::ostream& operator<<(std::ostream& salida, const Receta& receta) {
    salida << receta.nombrePlatillo << std::endl;
    salida << receta.autorReceta;
    salida << static_cast<int>(receta.categoriaReceta) << std::endl;
    salida << receta.tiempoPreparacionMinutos << std::endl;
    salida << receta.procedimientoPasos << std::endl;
    salida << receta.rutaImagenPlatillo << std::endl;
    salida << receta.ingredientesListaOrdenada.obtenerCantidadElementos() << std::endl;
    for (int i = 0; i < receta.ingredientesListaOrdenada.obtenerCantidadElementos(); ++i) {
        salida << receta.ingredientesListaOrdenada.obtenerEnPosicion(i);
    } return salida;
}

// CORRECCIÓN CRÍTICA: Consumir robustamente el newline después de cada lectura numérica
std::istream& operator>>(std::istream& entrada, Receta& receta) {
    receta.ingredientesListaOrdenada.limpiarLista();

    std::getline(entrada, receta.nombrePlatillo);
    entrada >> receta.autorReceta;
    
    int categoriaInt;
    entrada >> categoriaInt;
    // CRÍTICO: Consumir el resto de la línea después de la lectura numérica
    entrada.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
    receta.categoriaReceta = static_cast<Categoria>(categoriaInt);
    
    entrada >> receta.tiempoPreparacionMinutos;
    // CRÍTICO: Consumir el resto de la línea después de la lectura numérica
    entrada.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
    std::getline(entrada, receta.procedimientoPasos);
    
    std::getline(entrada, receta.rutaImagenPlatillo);
    
    int cantidadIngredientes = 0;
    // Debemos verificar si la lectura fue exitosa antes de usar el valor
    if (!(entrada >> cantidadIngredientes)) {
        return entrada;
    }
    // CRÍTICO: Consumir el resto de la línea después de la lectura numérica
    entrada.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
    
    for (int i = 0; i < cantidadIngredientes; ++i) {
        Ingrediente ing;
        entrada >> ing;
        if (!entrada.fail()) {
            receta.ingredientesListaOrdenada.agregarAlFinal(ing);
        } else {
            entrada.clear();
            break;
        }
    } 
    return entrada;
}


===== C:\Universidad\estructuras-de-datos\src\persistence\ManejadorArchivosIngredientes.cpp =====


===== C:\Universidad\estructuras-de-datos\src\persistence\ManejadorArchivosRecetas.cpp =====
#include "persistence/ManejadorArchivosRecetas.hpp"
#include <fstream>
#include <iostream>
#include <cstdio>

// Implementación de métodos estáticos

bool ManejadorArchivosRecetas::verificarIntegridad(const std::string& rutaArchivo) {
    std::ifstream archivo(rutaArchivo);
    return archivo.good();
}

void ManejadorArchivosRecetas::crearRespaldo(const std::string& rutaArchivo) {
    std::ifstream src(rutaArchivo, std::ios::binary);
    std::ofstream dst(rutaArchivo + ".bak", std::ios::binary);
    dst << src.rdbuf();
}

InfoArchivo ManejadorArchivosRecetas::obtenerInformacionArchivo(const std::string& rutaArchivo) {
    InfoArchivo info;
    info.ruta = rutaArchivo;
    std::ifstream f(rutaArchivo, std::ios::binary | std::ios::ate);
    if (f.good()) {
        info.existe = true;
        info.tamanoByte = f.tellg();
    } else {
        info.existe = false;
        info.tamanoByte = 0;
    }
    return info;
}

bool ManejadorArchivosRecetas::crearArchivoSiNoExiste(const std::string& rutaArchivo) {
    std::ifstream f(rutaArchivo);
    if (!f.good()) {
        std::ofstream nuevo(rutaArchivo);
        if (nuevo.good()) {
            nuevo.close();
            return true;
        }
        return false;
    }
    return true;
}

bool ManejadorArchivosRecetas::eliminarArchivo(const std::string& rutaArchivo) {
    return std::remove(rutaArchivo.c_str()) == 0;
}

bool ManejadorArchivosRecetas::renombrarArchivo(const std::string& rutaActual, const std::string& rutaNueva) {
    return std::rename(rutaActual.c_str(), rutaNueva.c_str()) == 0;
}

bool ManejadorArchivosRecetas::crearRespaldoAutomatico(const std::string& rutaArchivo) {
    crearRespaldo(rutaArchivo);
    return true;
}

bool ManejadorArchivosRecetas::restaurarDesdeRespaldo(const std::string& rutaRespaldo, const std::string& rutaDestino) {
    std::ifstream src(rutaRespaldo, std::ios::binary);
    std::ofstream dst(rutaDestino, std::ios::binary);
    if (src.good() && dst.good()) {
        dst << src.rdbuf();
        return true;
    }
    return false;
}

void ManejadorArchivosRecetas::limpiarArchivosAntiguos(const std::string& ruta, int diasAntiguedad) {
    (void)ruta;
    (void)diasAntiguedad;
}


===== C:\Universidad\estructuras-de-datos\src\persistence\RutasAssets.cpp =====
// ============================================================================
// ARCHIVO: src/persistence/RutasAssets.cpp
// ImplementaciÃ³n del gestor de rutas
// ============================================================================
#include "persistence/RutasAssets.hpp"
// #include "utils/ConvertidoresFormatos.hpp" // Ya no lo necesitamos aquÃ­ gracias al switch
#include <iostream> 

// ============================================================================
// INICIALIZACIÃ“N DE CONSTANTES ESTÃTICAS
// ============================================================================

const std::string RutasAssets::RUTA_RELATIVA_ASSETS = "assets";
const std::string RutasAssets::RUTA_RELATIVA_FONTS = "assets/fonts";
const std::string RutasAssets::RUTA_RELATIVA_ICONS = "assets/images/icons";
const std::string RutasAssets::RUTA_RELATIVA_PLATILLOS = "assets/images/platillos";
const std::string RutasAssets::RUTA_RELATIVA_DATA = "assets/data";

// ============================================================================
// RUTAS A FUENTES (FONTS)
// ============================================================================

std::string RutasAssets::obtenerRutaFuenteRegular() {
    return RUTA_RELATIVA_FONTS + "/font.ttf";
}

std::string RutasAssets::obtenerRutaFuenteNegrita() {
    return RUTA_RELATIVA_FONTS + "/font.ttf";
}

// ========================================================================
// RUTAS A ICONOS Y BOTONES
// ========================================================================

std::string RutasAssets::obtenerRutaIconoBotonAgregar() {
    return RUTA_RELATIVA_ICONS + "/boton_agregar.png";
}

std::string RutasAssets::obtenerRutaIconoBotonEditar() {
    return RUTA_RELATIVA_ICONS + "/boton_editar.png";
}

std::string RutasAssets::obtenerRutaIconoBotonEliminar() {
    return RUTA_RELATIVA_ICONS + "/boton_eliminar.png";
}

std::string RutasAssets::obtenerRutaIconoBotonVolver() {
    return RUTA_RELATIVA_ICONS + "/boton_volver.png";
}

std::string RutasAssets::obtenerRutaIconoBotonGuardar() {
    return RUTA_RELATIVA_ICONS + "/boton_guardar.png";
}

// CORRECCIÃ“N: Mapeo manual para evitar problemas con caracteres especiales (Ã±, acentos)
std::string RutasAssets::obtenerRutaCarpetaImagenesPorCategoria(const Categoria& categoria) {
    switch (categoria) {
        case Categoria::DESAYUNO:
            return RUTA_RELATIVA_PLATILLOS + "/desayuno";
        case Categoria::COMIDA:
            return RUTA_RELATIVA_PLATILLOS + "/comida";
        case Categoria::CENA:
            return RUTA_RELATIVA_PLATILLOS + "/cena";
        case Categoria::NAVIDENO:
            // IMPORTANTE: La carpeta en disco debe llamarse "navideno" (sin Ã±)
            return RUTA_RELATIVA_PLATILLOS + "/navideno"; 
        case Categoria::SIN_CATEGORIZAR:
        default:
            return RUTA_RELATIVA_PLATILLOS + "/otros";
    }
}

std::string RutasAssets::obtenerRutaImagenPlatillo(
    const Categoria& categoria,
    const std::string& nombrePlatillo)
{
    // Por ahora devolvemos una imagen por defecto, luego podrÃ¡s buscar por nombre real
    std::string nombreArchivo = "default.png"; 
    return obtenerRutaCarpetaImagenesPorCategoria(categoria) + "/" + nombreArchivo;
}

std::string RutasAssets::obtenerRutaArchivoRecetario() {
    return RUTA_RELATIVA_DATA + "/recetario.dat";
}


===== C:\Universidad\estructuras-de-datos\src\ui\Boton.cpp =====
#include "ui/Boton.hpp"
#include <SDL3_image/SDL_image.h>
#include <iostream>

Boton::Boton(SDL_Renderer* renderer, const std::string& rutaImagen, float x, float y, float w, float h) 
    : textura(nullptr), activo(true), hover(false) {
    
    rectOriginal = {x, y, w, h};
    rectActual = rectOriginal;

    textura = IMG_LoadTexture(renderer, rutaImagen.c_str());
}

Boton::~Boton() {
    if (textura) {
        SDL_DestroyTexture(textura);
    }
}

// NUEVO MÉTODO IMPLEMENTADO
void Boton::cambiarImagen(SDL_Renderer* renderer, const std::string& nuevaRuta) {
    if (textura) {
        SDL_DestroyTexture(textura); // Borramos la vieja para no llenar la memoria
    }
    textura = IMG_LoadTexture(renderer, nuevaRuta.c_str());
    
    if (!textura) {
        // std::cerr << "[WARN] No se pudo cargar nueva imagen boton: " << nuevaRuta << std::endl;
    }
}

void Boton::actualizar() {
    if (!activo) return;

    float mx, my;
    SDL_GetMouseState(&mx, &my);

    bool colision = (mx >= rectOriginal.x && mx <= (rectOriginal.x + rectOriginal.w) &&
                     my >= rectOriginal.y && my <= (rectOriginal.y + rectOriginal.h));

    hover = colision;

    float targetScale = hover ? 1.1f : 1.0f;
    float targetW = rectOriginal.w * targetScale;
    float targetH = rectOriginal.h * targetScale;
    
    float speed = 0.2f; 
    rectActual.w += (targetW - rectActual.w) * speed;
    rectActual.h += (targetH - rectActual.h) * speed;

    rectActual.x = rectOriginal.x - (rectActual.w - rectOriginal.w) / 2.0f;
    rectActual.y = rectOriginal.y - (rectActual.h - rectOriginal.h) / 2.0f;
}

void Boton::render(SDL_Renderer* renderer) {
    if (!activo) return;

    if (textura) {
        SDL_RenderTexture(renderer, textura, nullptr, &rectActual);
    } else {
        if (hover) SDL_SetRenderDrawColor(renderer, 255, 150, 150, 255);
        else SDL_SetRenderDrawColor(renderer, 200, 50, 50, 255);
        SDL_RenderRect(renderer, &rectActual);
    }
}

bool Boton::estaPresionado(float mouseX, float mouseY) const {
    if (!activo) return false;
    return (mouseX >= rectOriginal.x && mouseX <= (rectOriginal.x + rectOriginal.w) &&
            mouseY >= rectOriginal.y && mouseY <= (rectOriginal.y + rectOriginal.h));
}


===== C:\Universidad\estructuras-de-datos\src\ui\CajaDeTexto.cpp =====
#include "ui/CajaDeTexto.hpp"
#include "utils/RenderizadorTextos.hpp"

CajaDeTexto::CajaDeTexto(SDL_Window* win, float x, float y, float w, float h, TTF_Font* f)
    : ventana(win), rect{x, y, w, h}, texto(""), placeholder(""), tieneFoco(false), fuente(f), texturaTexto(nullptr) {}

CajaDeTexto::~CajaDeTexto() {
    if (texturaTexto) {
        SDL_DestroyTexture(texturaTexto);
    }
}

void CajaDeTexto::establecerTexto(const std::string& t) {
    texto = t;
    if (texturaTexto) {
        SDL_DestroyTexture(texturaTexto);
        texturaTexto = nullptr;
    }
}

void CajaDeTexto::manejarEvento(const SDL_Event& evento) {
    if (evento.type == SDL_EVENT_MOUSE_BUTTON_DOWN) {
        float mx = evento.button.x;
        float my = evento.button.y;
        bool clicDentro = (mx >= rect.x && mx <= rect.x + rect.w &&
                           my >= rect.y && my <= rect.y + rect.h);
        
        if (clicDentro && !tieneFoco) {
            tieneFoco = true;
            SDL_StartTextInput(ventana); 
        } else if (!clicDentro && tieneFoco) {
            tieneFoco = false;
            SDL_StopTextInput(ventana);
        }
    }
    else if (tieneFoco && evento.type == SDL_EVENT_TEXT_INPUT) {
        texto += evento.text.text;
        if (texturaTexto) { SDL_DestroyTexture(texturaTexto); texturaTexto = nullptr; }
    }
    else if (tieneFoco && evento.type == SDL_EVENT_KEY_DOWN) {
        if (evento.key.key == SDLK_BACKSPACE && !texto.empty()) {
            texto.pop_back();
            if (texturaTexto) { SDL_DestroyTexture(texturaTexto); texturaTexto = nullptr; }
        }
    }
}

void CajaDeTexto::regenerarTextura(SDL_Renderer* renderer) {
    if (texturaTexto) SDL_DestroyTexture(texturaTexto);
    texturaTexto = nullptr;

    if (texto.empty() && placeholder.empty()) return;

    std::string textoAmostrar = texto.empty() ? placeholder : texto;
    // Color gris suave para placeholder, negro solido para texto real
    SDL_Color color = texto.empty() ? SDL_Color{150, 150, 150, 255} : SDL_Color{50, 50, 50, 255};

    texturaTexto = RenderizadorTextos::renderizarTexto(renderer, fuente, textoAmostrar, color);
}

// --- AQUÍ ESTÁ EL NUEVO DISEÑO ---
void CajaDeTexto::render(SDL_Renderer* renderer) {
    // Habilitar blending para transparencias (sombras)
    SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);

    // 1. SOMBRA (Depth Effect)
    // Dibujamos un rectangulo gris semitransparente desplazado ligeramente
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 30); // Negro al 12% opacidad
    SDL_FRect rSombra = {rect.x + 4, rect.y + 4, rect.w, rect.h};
    SDL_RenderFillRect(renderer, &rSombra);

    // 2. FONDO (Blanco Puro)
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    SDL_RenderFillRect(renderer, &rect);

    // 3. INDICADOR DE ESTADO (Borde Inferior)
    if (tieneFoco) {
        // ACTIVO: Barra inferior gruesa de color "Azul Cornflower" (Pastel intenso)
        SDL_SetRenderDrawColor(renderer, 100, 149, 237, 255); 
        SDL_FRect rLinea = {rect.x, rect.y + rect.h - 3, rect.w, 3}; // 3px de alto
        SDL_RenderFillRect(renderer, &rLinea);
    } else {
        // INACTIVO: Borde sutil gris alrededor (Estilo tarjeta)
        SDL_SetRenderDrawColor(renderer, 200, 200, 200, 255);
        SDL_RenderRect(renderer, &rect);
    }
    
    SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_NONE);

    // 4. TEXTO
    if (!texturaTexto) {
        regenerarTextura(renderer);
    }

    if (texturaTexto) {
        float tw = (float)texturaTexto->w;
        float th = (float)texturaTexto->h;
        
        // Padding (margen interno) para que el texto no pegue al borde
        float paddingX = 10.0f;
        // Centrado vertical
        float posY = rect.y + (rect.h - th) / 2.0f;
        
        // Si es multilínea o muy alto (como el campo de procedimiento), alinear arriba
        if (rect.h > 50) { 
            posY = rect.y + 10.0f; 
        }

        // Clipping: Evitar que el texto se salga de la caja si es muy largo
        SDL_SetRenderClipRect(renderer, (const SDL_Rect*)&rect);
        
        SDL_FRect dst = { rect.x + paddingX, posY, tw, th };
        SDL_RenderTexture(renderer, texturaTexto, nullptr, &dst);
        
        SDL_SetRenderClipRect(renderer, nullptr); // Desactivar clip
    }
}


===== C:\Universidad\estructuras-de-datos\src\ui\ElementosUIReutilizables.cpp =====


===== C:\Universidad\estructuras-de-datos\src\ui\GameState.cpp =====


===== C:\Universidad\estructuras-de-datos\src\ui\PantallaAgregarReceta.cpp =====
#include "ui/PantallaAgregarReceta.hpp"
#include "ui/PantallaMenuPrincipal.hpp"
#include "Game.hpp"
#include "persistence/RutasAssets.hpp"
#include "utils/RenderizadorTextos.hpp"
#include "utils/ValidadorEntradas.hpp"
#include "entities/Categoria.hpp"
#include <iostream>
#include <cmath>
#include <filesystem> 
#include <SDL3_image/SDL_image.h>

namespace fs = std::filesystem;

PantallaAgregarReceta::PantallaAgregarReceta()
    : fuenteTitulo(nullptr), fuenteLabels(nullptr), fuenteInputs(nullptr), fuenteLista(nullptr), fuenteUI(nullptr),
      texturaTitulo(nullptr),
      inputNombre(nullptr), inputAutor(nullptr), inputTiempo(nullptr), inputProcedimiento(nullptr),
      inputIngNombre(nullptr), inputIngCant(nullptr), inputIngUnidad(nullptr), 
      btnAgregarIngrediente(nullptr), btnQuitarIngrediente(nullptr),
      texPreviewImagen(nullptr), imagenCargada(false),
      categoriaSeleccionada(Categoria::DESAYUNO),
      btnCambiarCategoria(nullptr), texturaCategoriaActual(nullptr),
      btnGuardar(nullptr), btnCancelar(nullptr),
      modoEdicion(false), tempNombre(""), tempAutor(""), tempTiempo(""), tempProc(""), nombreOriginal("") {}

PantallaAgregarReceta::PantallaAgregarReceta(const Receta& r) : PantallaAgregarReceta() {
    modoEdicion = true;
    nombreOriginal = r.obtenerNombrePlatillo();
    
    // Guardar datos para init()
    tempNombre = r.obtenerNombrePlatillo();
    tempAutor = r.obtenerAutor().obtenerNombreCompleto();
    tempTiempo = std::to_string(r.obtenerTiempoPreparacion());
    tempProc = r.obtenerProcedimiento();
    categoriaSeleccionada = r.obtenerCategoria();
    
    rutaImagenTemporal = r.obtenerRutaImagen();
    if (!rutaImagenTemporal.empty()) imagenCargada = true;

    // Copiar ingredientes
    const auto& lista = r.obtenerIngredientesConstante();
    for(int i=0; i<lista.obtenerCantidadElementos(); ++i) {
        listaIngredientesTemp.agregarAlFinal(lista.obtenerEnPosicion(i));
    }
}

PantallaAgregarReceta::~PantallaAgregarReceta() {
    cleanup();
}

void PantallaAgregarReceta::init(Game& game) {
    SDL_Renderer* renderer = game.getRenderer();
    SDL_Window* window = game.getWindow();
    int w, h;
    SDL_GetRenderOutputSize(renderer, &w, &h);

    fuenteTitulo = TTF_OpenFont(RutasAssets::obtenerRutaFuenteNegrita().c_str(), 36);
    fuenteLabels = TTF_OpenFont(RutasAssets::obtenerRutaFuenteRegular().c_str(), 18);
    fuenteInputs = TTF_OpenFont(RutasAssets::obtenerRutaFuenteRegular().c_str(), 20);
    fuenteLista  = TTF_OpenFont(RutasAssets::obtenerRutaFuenteRegular().c_str(), 18);
    fuenteUI     = TTF_OpenFont(RutasAssets::obtenerRutaFuenteRegular().c_str(), 14);

    std::string tit = modoEdicion ? "EDITAR RECETA" : "NUEVA RECETA";
    texturaTitulo = RenderizadorTextos::renderizarTexto(renderer, fuenteTitulo, tit, {50, 50, 70, 255});
    if (texturaTitulo) rectTitulo = { 50.0f, 20.0f, (float)texturaTitulo->w, (float)texturaTitulo->h };

    float yC1 = 90.0f;
    inputNombre = new CajaDeTexto(window, 70, yC1, 400, 35, fuenteInputs);
    inputNombre->establecerPlaceholder("Nombre del platillo");
    if(modoEdicion) inputNombre->establecerTexto(tempNombre);

    inputAutor = new CajaDeTexto(window, 500, yC1, 300, 35, fuenteInputs);
    inputAutor->establecerPlaceholder("Nombre del Autor");
    if(modoEdicion) inputAutor->establecerTexto(tempAutor);

    rectPreviewImagen = { 830.0f, yC1, 130.0f, 130.0f }; 
    if (imagenCargada) {
        texPreviewImagen = IMG_LoadTexture(renderer, rutaImagenTemporal.c_str());
    }

    float yC1_Row2 = 150.0f;
    inputTiempo = new CajaDeTexto(window, 70, yC1_Row2, 100, 35, fuenteInputs);
    inputTiempo->establecerPlaceholder("Min");
    if(modoEdicion) inputTiempo->establecerTexto(tempTiempo);

    std::string iconCat = "assets/images/icons/cat_desayuno.png";
    switch(categoriaSeleccionada) {
         case Categoria::COMIDA: iconCat = "assets/images/icons/cat_comida.png"; break;
         case Categoria::CENA: iconCat = "assets/images/icons/cat_cena.png"; break;
         case Categoria::NAVIDENO: iconCat = "assets/images/icons/cat_navideno.png"; break;
         default: break;
    }
    btnCambiarCategoria = new Boton(renderer, iconCat, 300, yC1_Row2 - 15, 60, 60);
    actualizarTextoCategoria(renderer);

    float yC2 = 240.0f;
    inputIngNombre = new CajaDeTexto(window, 70, yC2, 350, 35, fuenteInputs);
    inputIngNombre->establecerPlaceholder("Ingrediente");
    inputIngCant = new CajaDeTexto(window, 440, yC2, 100, 35, fuenteInputs);
    inputIngCant->establecerPlaceholder("Cant.");
    inputIngUnidad = new CajaDeTexto(window, 560, yC2, 120, 35, fuenteInputs);
    inputIngUnidad->establecerPlaceholder("Unidad");

    btnAgregarIngrediente = new Boton(renderer, "assets/images/icons/boton_agregar.png", 700, yC2, 35, 35);
    btnQuitarIngrediente = new Boton(renderer, "assets/images/icons/boton_menos.png", 745, yC2, 35, 35);

    float yC3 = 470.0f;
    inputProcedimiento = new CajaDeTexto(window, 70, yC3, w - 140, 180, fuenteInputs);
    inputProcedimiento->establecerPlaceholder("Describa el procedimiento...");
    if(modoEdicion) inputProcedimiento->establecerTexto(tempProc);

    btnGuardar = new Boton(renderer, RutasAssets::obtenerRutaIconoBotonGuardar(), w - 120, h - 80, 60, 60);
    btnCancelar = new Boton(renderer, RutasAssets::obtenerRutaIconoBotonVolver(), 60, h - 80, 60, 60);

    // Renderizar lista ingredientes cargados
    for(int i=0; i<listaIngredientesTemp.obtenerCantidadElementos(); ++i) {
        Ingrediente ing = listaIngredientesTemp.obtenerEnPosicion(i);
        std::string txt = ing.obtenerNombre() + " | " + ing.obtenerCantidad() + " " + ing.obtenerUnidad();
        SDL_Texture* t = RenderizadorTextos::renderizarTexto(renderer, fuenteLista, txt, {60,60,60,255});
        if(t) {
            float yL = 290.0f + (listaVisualIngredientes.size() * 30.0f);
            if(listaVisualIngredientes.size()<5) {
                ItemIngredienteVisual it; it.textura=t; it.rect={80.0f, yL, (float)t->w, (float)t->h};
                listaVisualIngredientes.push_back(it);
            } else SDL_DestroyTexture(t);
        }
    }
}

void PantallaAgregarReceta::cleanup() {
    if (texturaTitulo) { SDL_DestroyTexture(texturaTitulo); texturaTitulo = nullptr; }
    if (texturaCategoriaActual) { SDL_DestroyTexture(texturaCategoriaActual); texturaCategoriaActual = nullptr; }
    if (texPreviewImagen) { SDL_DestroyTexture(texPreviewImagen); texPreviewImagen = nullptr; }
    
    for(auto& item : listaVisualIngredientes) {
        if (item.textura) SDL_DestroyTexture(item.textura);
    }
    listaVisualIngredientes.clear();
    
    if (fuenteTitulo) { TTF_CloseFont(fuenteTitulo); fuenteTitulo = nullptr; }
    if (fuenteLabels) { TTF_CloseFont(fuenteLabels); fuenteLabels = nullptr; }
    if (fuenteInputs) { TTF_CloseFont(fuenteInputs); fuenteInputs = nullptr; }
    if (fuenteLista) { TTF_CloseFont(fuenteLista); fuenteLista = nullptr; }
    if (fuenteUI) { TTF_CloseFont(fuenteUI); fuenteUI = nullptr; }

    if (btnGuardar) { delete btnGuardar; btnGuardar = nullptr; }
    if (btnCancelar) { delete btnCancelar; btnCancelar = nullptr; }
    if (btnCambiarCategoria) { delete btnCambiarCategoria; btnCambiarCategoria = nullptr; }
    if (btnAgregarIngrediente) { delete btnAgregarIngrediente; btnAgregarIngrediente = nullptr; }
    if (btnQuitarIngrediente) { delete btnQuitarIngrediente; btnQuitarIngrediente = nullptr; }

    if (inputNombre) { delete inputNombre; inputNombre = nullptr; }
    if (inputAutor) { delete inputAutor; inputAutor = nullptr; }
    if (inputTiempo) { delete inputTiempo; inputTiempo = nullptr; }
    if (inputIngNombre) { delete inputIngNombre; inputIngNombre = nullptr; }
    if (inputIngCant) { delete inputIngCant; inputIngCant = nullptr; }
    if (inputIngUnidad) { delete inputIngUnidad; inputIngUnidad = nullptr; }
    if (inputProcedimiento) { delete inputProcedimiento; inputProcedimiento = nullptr; }
}

void PantallaAgregarReceta::actualizarTextoCategoria(SDL_Renderer* renderer) {
    if (texturaCategoriaActual) SDL_DestroyTexture(texturaCategoriaActual);
    std::string textoCat = categoriaATexto(categoriaSeleccionada);
    texturaCategoriaActual = RenderizadorTextos::renderizarTexto(renderer, fuenteLabels, textoCat, {255, 255, 255, 255});
    if (texturaCategoriaActual) rectCategoria = { 380.0f, 155.0f, (float)texturaCategoriaActual->w, (float)texturaCategoriaActual->h };

    if (btnCambiarCategoria) {
        std::string rutaIcono = "";
        switch (categoriaSeleccionada) {
            case Categoria::DESAYUNO: rutaIcono = "assets/images/icons/cat_desayuno.png"; break;
            case Categoria::COMIDA:   rutaIcono = "assets/images/icons/cat_comida.png"; break;
            case Categoria::CENA:     rutaIcono = "assets/images/icons/cat_cena.png"; break;
            case Categoria::NAVIDENO: rutaIcono = "assets/images/icons/cat_navideno.png"; break;
            default:                  rutaIcono = "assets/images/icons/cat_desayuno.png"; break;
        }
        btnCambiarCategoria->cambiarImagen(renderer, rutaIcono);
    }
}

void PantallaAgregarReceta::agregarIngredienteALista(SDL_Renderer* renderer) {
    std::string nom = inputIngNombre->obtenerTexto();
    std::string cant = inputIngCant->obtenerTexto();
    std::string uni = inputIngUnidad->obtenerTexto();

    if (nom.empty() || cant.empty()) return;

    Ingrediente nuevoIng(nom, cant, uni);
    listaIngredientesTemp.agregarAlFinal(nuevoIng);

    std::string textoVisual = nom + "  |  " + cant + " " + uni;
    SDL_Texture* tex = RenderizadorTextos::renderizarTexto(renderer, fuenteLista, textoVisual, {60, 60, 60, 255});
    
    if (tex) {
        float yLista = 290.0f + (listaVisualIngredientes.size() * 30.0f);
        if (listaVisualIngredientes.size() < 5) { 
            ItemIngredienteVisual item;
            item.textura = tex;
            item.rect = { 80.0f, yLista, (float)tex->w, (float)tex->h };
            listaVisualIngredientes.push_back(item);
        } else {
            SDL_DestroyTexture(tex);
        }
    }
    inputIngNombre->establecerTexto("");
    inputIngCant->establecerTexto("");
    inputIngUnidad->establecerTexto("");
}

void PantallaAgregarReceta::eliminarUltimoIngrediente() {
    if (listaIngredientesTemp.estaVacia()) return;
    try {
        listaIngredientesTemp.eliminarDelFinal();
        if (!listaVisualIngredientes.empty()) {
            SDL_Texture* t = listaVisualIngredientes.back().textura;
            if (t) SDL_DestroyTexture(t);
            listaVisualIngredientes.pop_back();
        }
    } catch (...) {}
}

void PantallaAgregarReceta::procesarArchivoDroppeado(SDL_Renderer* renderer, const char* ruta) {
    if (!ruta) return;
    if (texPreviewImagen) { SDL_DestroyTexture(texPreviewImagen); texPreviewImagen = nullptr; }
    
    texPreviewImagen = IMG_LoadTexture(renderer, ruta);
    if (texPreviewImagen) {
        rutaImagenTemporal = std::string(ruta);
        imagenCargada = true;
    }
}

void PantallaAgregarReceta::handleEvents(Game& game) {
    SDL_Event evento;
    while (SDL_PollEvent(&evento)) {
        if (evento.type == SDL_EVENT_QUIT) game.setEstaCorriendo(false);

        if (evento.type == SDL_EVENT_DROP_FILE) {
            procesarArchivoDroppeado(game.getRenderer(), evento.drop.data);
        }

        if (inputNombre) inputNombre->manejarEvento(evento);
        if (inputAutor) inputAutor->manejarEvento(evento);
        if (inputTiempo) inputTiempo->manejarEvento(evento);
        if (inputIngNombre) inputIngNombre->manejarEvento(evento);
        if (inputIngCant) inputIngCant->manejarEvento(evento);
        if (inputIngUnidad) inputIngUnidad->manejarEvento(evento);
        if (inputProcedimiento) inputProcedimiento->manejarEvento(evento);

        if (evento.type == SDL_EVENT_MOUSE_BUTTON_DOWN && evento.button.button == SDL_BUTTON_LEFT) {
            float mx = evento.button.x;
            float my = evento.button.y;

            if (btnCancelar && btnCancelar->estaPresionado(mx, my)) {
                game.popEstado();
            }
            else if (btnGuardar && btnGuardar->estaPresionado(mx, my)) {
                guardarReceta(game);
            }
            else if (btnCambiarCategoria && btnCambiarCategoria->estaPresionado(mx, my)) {
                int catInt = static_cast<int>(categoriaSeleccionada);
                catInt = (catInt + 1) % 4;
                categoriaSeleccionada = static_cast<Categoria>(catInt);
                actualizarTextoCategoria(game.getRenderer());
            }
            else if (btnAgregarIngrediente && btnAgregarIngrediente->estaPresionado(mx, my)) {
                agregarIngredienteALista(game.getRenderer());
            }
            else if (btnQuitarIngrediente && btnQuitarIngrediente->estaPresionado(mx, my)) {
                eliminarUltimoIngrediente();
            }
        }
    }
}

void PantallaAgregarReceta::update(Game& game) {
    (void)game;
    if (btnGuardar) btnGuardar->actualizar();
    if (btnCancelar) btnCancelar->actualizar();
    if (btnCambiarCategoria) btnCambiarCategoria->actualizar();
    if (btnAgregarIngrediente) btnAgregarIngrediente->actualizar();
    if (btnQuitarIngrediente) btnQuitarIngrediente->actualizar();
}

void PantallaAgregarReceta::render(Game& game) {
    SDL_Renderer* renderer = game.getRenderer();
    int w, h;
    SDL_GetRenderOutputSize(renderer, &w, &h);
    
    float tiempo = SDL_GetTicks() / 1000.0f;
    Uint8 baseB = 240 + (Uint8)(std::sin(tiempo) * 10);
    SDL_SetRenderDrawColor(renderer, 235, 235, baseB, 255);
    SDL_FRect bg = {0, 0, (float)w, (float)h};
    SDL_RenderFillRect(renderer, &bg);

    SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 180);

    SDL_FRect card1 = {40, 70, (float)w-80, 130};
    SDL_RenderFillRect(renderer, &card1);
    SDL_FRect card2 = {40, 210, (float)w-80, 230};
    SDL_RenderFillRect(renderer, &card2);
    SDL_FRect card3 = {40, 450, (float)w-80, 220};
    SDL_RenderFillRect(renderer, &card3);
    SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_NONE);

    SDL_SetRenderDrawColor(renderer, 200, 200, 220, 255);
    SDL_RenderFillRect(renderer, &rectPreviewImagen);
    
    if (texPreviewImagen) {
        SDL_RenderTexture(renderer, texPreviewImagen, nullptr, &rectPreviewImagen);
    } else {
        SDL_Color cHint = {150, 150, 160, 255};
        if (fuenteUI) {
             SDL_Texture* tHint = RenderizadorTextos::renderizarTexto(renderer, fuenteUI, "Arrastra Foto", cHint);
             if (tHint) {
                SDL_FRect rHint = { rectPreviewImagen.x + 15, rectPreviewImagen.y + 55, (float)tHint->w, (float)tHint->h };
                SDL_RenderTexture(renderer, tHint, nullptr, &rHint);
                SDL_DestroyTexture(tHint);
             }
        }
    }

    if (texturaTitulo) SDL_RenderTexture(renderer, texturaTitulo, nullptr, &rectTitulo);

    SDL_Color cLabel = {100, 100, 120, 255};
    RenderizadorTextos::renderizarTexto(renderer, fuenteLabels, "Detalles Basicos", cLabel); 

    if (texturaCategoriaActual) {
        SDL_FRect rBadge = { rectCategoria.x - 15, rectCategoria.y - 5, rectCategoria.w + 30, rectCategoria.h + 10 };
        SDL_SetRenderDrawColor(renderer, 100, 180, 255, 255); 
        SDL_RenderFillRect(renderer, &rBadge);
        SDL_RenderTexture(renderer, texturaCategoriaActual, nullptr, &rectCategoria);
    }
    if (btnCambiarCategoria) btnCambiarCategoria->render(renderer);

    float yList = 285.0f;
    for(size_t i=0; i<listaVisualIngredientes.size(); ++i) {
        if (i % 2 == 0) SDL_SetRenderDrawColor(renderer, 240, 245, 255, 255);
        else SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
        SDL_FRect rRow = { 60, yList + (i*30) - 2, (float)w-120, 30 };
        SDL_RenderFillRect(renderer, &rRow);
        SDL_RenderTexture(renderer, listaVisualIngredientes[i].textura, nullptr, &listaVisualIngredientes[i].rect);
    }

    if (inputNombre) inputNombre->render(renderer);
    if (inputAutor) inputAutor->render(renderer);
    if (inputTiempo) inputTiempo->render(renderer);
    if (inputIngNombre) inputIngNombre->render(renderer);
    if (inputIngCant) inputIngCant->render(renderer);
    if (inputIngUnidad) inputIngUnidad->render(renderer);
    if (btnAgregarIngrediente) btnAgregarIngrediente->render(renderer);
    if (btnQuitarIngrediente) btnQuitarIngrediente->render(renderer);
    if (inputProcedimiento) inputProcedimiento->render(renderer);
    if (btnGuardar) btnGuardar->render(renderer);
    if (btnCancelar) btnCancelar->render(renderer);
}

void PantallaAgregarReceta::guardarReceta(Game& game) {
    try {
        std::string nombre = inputNombre->obtenerTexto();
        std::string autorStr = inputAutor->obtenerTexto();
        std::string tiempoStr = inputTiempo->obtenerTexto();
        std::string procedimiento = inputProcedimiento->obtenerTexto();

        if (nombre.empty() || tiempoStr.empty()) {
            std::cout << "Faltan datos!" << std::endl;
            return;
        }
        if (!ValidadorEntradas::verificarSiEsNumeroEnteroPositivo(tiempoStr)) return;

        Nombre autorObj(autorStr, "", ""); 
        int tiempo = std::stoi(tiempoStr);

        Receta nuevaReceta(nombre, autorObj, categoriaSeleccionada, tiempo, procedimiento);
        
        for (int i = 0; i < listaIngredientesTemp.obtenerCantidadElementos(); ++i) {
            nuevaReceta.agregarIngredienteOrdenado(listaIngredientesTemp.obtenerEnPosicion(i));
        }

        if (imagenCargada && !rutaImagenTemporal.empty()) {
            std::string carpetaDestino = "assets/images/platillos/otros"; 
            switch(categoriaSeleccionada) {
                case Categoria::DESAYUNO: carpetaDestino = "assets/images/platillos/desayuno"; break;
                case Categoria::COMIDA: carpetaDestino = "assets/images/platillos/comida"; break;
                case Categoria::CENA: carpetaDestino = "assets/images/platillos/cena"; break;
                case Categoria::NAVIDENO: carpetaDestino = "assets/images/platillos/navideno"; break;
                default: carpetaDestino = "assets/images/platillos/otros"; break;
            }

            fs::create_directories(carpetaDestino);
            std::string extension = fs::path(rutaImagenTemporal).extension().string();
            std::string rutaFinal = carpetaDestino + "/" + nombre + extension;
            try {
                fs::copy_file(rutaImagenTemporal, rutaFinal, fs::copy_options::overwrite_existing);
                nuevaReceta.establecerRutaImagen(rutaFinal);
            } catch (...) {}
        }

        // MODO EDICIÓN: Borrar la vieja antes de guardar la nueva
        if (modoEdicion) {
            game.getManejadorRecetas().eliminarRecetaPorNombre(nombreOriginal);
        }

        game.getManejadorRecetas().agregarRecetaNueva(nuevaReceta);
        game.popEstado(); 

    } catch (...) {}
}


===== C:\Universidad\estructuras-de-datos\src\ui\PantallaBusquedaOrdenamiento.cpp =====
#include "ui/PantallaBusquedaOrdenamiento.hpp"
#include "Game.hpp"
#include "entities/Receta.hpp"
#include "datastructures/managers/ManejadorRecetas.hpp"
#include "persistence/RutasAssets.hpp"
#include "utils/RenderizadorTextos.hpp"
#include <iostream>

PantallaBusquedaOrdenamiento::PantallaBusquedaOrdenamiento()
    : fuenteTitulo(nullptr), fuenteDetalle(nullptr), texturaTitulo(nullptr),
      btnOrdenarNombre(nullptr), btnOrdenarTiempo(nullptr), btnVolver(nullptr),
      inputBusqueda(nullptr), btnBuscar(nullptr), 
      texturaResultado(nullptr) {
    resultadoTexto = "Selecciona una opcion o busca una receta.";
}

PantallaBusquedaOrdenamiento::~PantallaBusquedaOrdenamiento() {
    cleanup();
}

void PantallaBusquedaOrdenamiento::init(Game& game) {
    SDL_Renderer* renderer = game.getRenderer();
    SDL_Window* window = game.getWindow(); 
    int w, h;
    SDL_GetRenderOutputSize(renderer, &w, &h);

    fuenteTitulo = TTF_OpenFont(RutasAssets::obtenerRutaFuenteNegrita().c_str(), 36);
    fuenteDetalle = TTF_OpenFont(RutasAssets::obtenerRutaFuenteRegular().c_str(), 24);

    texturaTitulo = RenderizadorTextos::renderizarTexto(renderer, fuenteTitulo, "BUSCAR Y ORDENAR", {0,0,0,255});
    if (texturaTitulo) {
        rectTitulo.x = (w - (float)texturaTitulo->w)/2.0f;
        rectTitulo.y = 40.0f;
        rectTitulo.w = (float)texturaTitulo->w;
        rectTitulo.h = (float)texturaTitulo->h;
    }

    float centroX = w / 2.0f;
    float startY = 120.0f;

    btnOrdenarNombre = new Boton(renderer, RutasAssets::obtenerRutaIconoBotonGuardar(), centroX - 120, startY, 80, 80);
    btnOrdenarTiempo = new Boton(renderer, RutasAssets::obtenerRutaIconoBotonEditar(), centroX + 40, startY, 80, 80);

    float searchY = 250.0f;
    inputBusqueda = new CajaDeTexto(window, centroX - 200, searchY, 300, 50, fuenteDetalle);
    inputBusqueda->establecerTexto("");
    inputBusqueda->establecerPlaceholder("Buscar platillo...");

    btnBuscar = new Boton(renderer, RutasAssets::obtenerRutaIconoBotonAgregar(), centroX + 120, searchY, 50, 50);
    btnVolver = new Boton(renderer, RutasAssets::obtenerRutaIconoBotonVolver(), 40, h - 100, 60, 60);

    actualizarTextoResultado(renderer, "Ordena (Arriba) o Busca (Abajo)");
}

// [CORRECCIÓN CRÍTICA] Cleanup seguro contra doble free
void PantallaBusquedaOrdenamiento::cleanup() {
    if (texturaTitulo) { SDL_DestroyTexture(texturaTitulo); texturaTitulo = nullptr; }
    if (texturaResultado) { SDL_DestroyTexture(texturaResultado); texturaResultado = nullptr; }
    
    if (fuenteTitulo) { TTF_CloseFont(fuenteTitulo); fuenteTitulo = nullptr; }
    if (fuenteDetalle) { TTF_CloseFont(fuenteDetalle); fuenteDetalle = nullptr; }

    if (btnOrdenarNombre) { delete btnOrdenarNombre; btnOrdenarNombre = nullptr; }
    if (btnOrdenarTiempo) { delete btnOrdenarTiempo; btnOrdenarTiempo = nullptr; }
    if (btnVolver) { delete btnVolver; btnVolver = nullptr; }
    if (inputBusqueda) { delete inputBusqueda; inputBusqueda = nullptr; }
    if (btnBuscar) { delete btnBuscar; btnBuscar = nullptr; }
}

void PantallaBusquedaOrdenamiento::actualizarTextoResultado(SDL_Renderer* renderer, const std::string& texto) {
    if (texturaResultado) SDL_DestroyTexture(texturaResultado);
    
    texturaResultado = RenderizadorTextos::renderizarTexto(renderer, fuenteDetalle, texto, {0, 50, 150, 255});
    
    if (texturaResultado) {
        int wW, wH;
        SDL_GetRenderOutputSize(renderer, &wW, &wH);
        rectResultado.x = (wW - (float)texturaResultado->w)/2.0f;
        rectResultado.y = 350.0f;
        rectResultado.w = (float)texturaResultado->w;
        rectResultado.h = (float)texturaResultado->h;
    }
}

void PantallaBusquedaOrdenamiento::handleEvents(Game& game) {
    SDL_Event ev;
    while (SDL_PollEvent(&ev)) {
        if (ev.type == SDL_EVENT_QUIT) game.setEstaCorriendo(false);

        if (inputBusqueda) inputBusqueda->manejarEvento(ev);

        if (ev.type == SDL_EVENT_MOUSE_BUTTON_DOWN && ev.button.button == SDL_BUTTON_LEFT) {
            float mx = ev.button.x;
            float my = ev.button.y;

            if (btnVolver && btnVolver->estaPresionado(mx, my)) {
                game.popEstado();
            }
            else if (btnOrdenarNombre && btnOrdenarNombre->estaPresionado(mx, my)) {
                game.getManejadorRecetas().ordenarRecetasPorNombre();
                actualizarTextoResultado(game.getRenderer(), "Recetas ordenadas alfabeticamente.");
            }
            else if (btnOrdenarTiempo && btnOrdenarTiempo->estaPresionado(mx, my)) {
                game.getManejadorRecetas().ordenarRecetasPorTiempoPreparacion();
                actualizarTextoResultado(game.getRenderer(), "Recetas ordenadas por tiempo.");
            }
            else if (btnBuscar && btnBuscar->estaPresionado(mx, my)) {
                std::string query = inputBusqueda->obtenerTexto();
                if (query.empty()) {
                    actualizarTextoResultado(game.getRenderer(), "Escribe un nombre primero.");
                } else {
                    Receta* encontrado = game.getManejadorRecetas().buscarRecetaBinariaPorNombre(query);
                    if (encontrado) {
                        std::string msg = "ENCONTRADO: " + encontrado->obtenerNombrePlatillo() + 
                                          " (" + std::to_string(encontrado->obtenerTiempoPreparacion()) + " min)";
                        actualizarTextoResultado(game.getRenderer(), msg);
                    } else {
                        actualizarTextoResultado(game.getRenderer(), "No encontrado.");
                    }
                }
            }
        }
    }
}

void PantallaBusquedaOrdenamiento::update(Game& game) {
    (void)game;
    if (btnOrdenarNombre) btnOrdenarNombre->actualizar();
    if (btnOrdenarTiempo) btnOrdenarTiempo->actualizar();
    if (btnBuscar) btnBuscar->actualizar();
    if (btnVolver) btnVolver->actualizar();
}

void PantallaBusquedaOrdenamiento::render(Game& game) {
    SDL_Renderer* r = game.getRenderer();
    
    SDL_SetRenderDrawColor(r, 240, 240, 245, 255);
    SDL_FRect bg = {0,0,1024,768};
    SDL_RenderFillRect(r, &bg);

    if (texturaTitulo) SDL_RenderTexture(r, texturaTitulo, nullptr, &rectTitulo);

    if (btnOrdenarNombre) btnOrdenarNombre->render(r);
    if (btnOrdenarTiempo) btnOrdenarTiempo->render(r);
    if (btnBuscar) btnBuscar->render(r);
    if (btnVolver) btnVolver->render(r);
    
    if (inputBusqueda) inputBusqueda->render(r);

    if (texturaResultado) SDL_RenderTexture(r, texturaResultado, nullptr, &rectResultado);
}


===== C:\Universidad\estructuras-de-datos\src\ui\PantallaDetalleReceta.cpp =====
#include "ui/PantallaDetalleReceta.hpp"
#include "ui/PantallaImagenCompleta.hpp"
#include "Game.hpp"
#include "persistence/RutasAssets.hpp"
#include "utils/RenderizadorTextos.hpp"
#include "entities/Categoria.hpp"
#include <iostream>
#include <SDL3_image/SDL_image.h>

PantallaDetalleReceta::PantallaDetalleReceta(const Receta& receta)
    : recetaAMostrar(receta), 
      fuenteTitulo(nullptr), fuenteSubtitulo(nullptr), fuenteTexto(nullptr),
      texTitulo(nullptr), rectTitulo({0,0,0,0}), 
      texImagenPlatillo(nullptr), rectImagenPlatillo({0,0,0,0}),
      btnVolver(nullptr) {}

PantallaDetalleReceta::~PantallaDetalleReceta() {
    cleanup();
}

void PantallaDetalleReceta::init(Game& game) {
    SDL_Renderer* renderer = game.getRenderer();
    int w, h;
    SDL_GetRenderOutputSize(renderer, &w, &h);

    fuenteTitulo = TTF_OpenFont(RutasAssets::obtenerRutaFuenteNegrita().c_str(), 32);
    fuenteSubtitulo = TTF_OpenFont(RutasAssets::obtenerRutaFuenteNegrita().c_str(), 20);
    fuenteTexto = TTF_OpenFont(RutasAssets::obtenerRutaFuenteRegular().c_str(), 18);

    texTitulo = RenderizadorTextos::renderizarTexto(renderer, fuenteTitulo, recetaAMostrar.obtenerNombrePlatillo(), {50, 50, 70, 255});
    if (texTitulo) {
        rectTitulo = { 50.0f, 30.0f, (float)texTitulo->w, (float)texTitulo->h };
    }

    std::string rutaImg = recetaAMostrar.obtenerRutaImagen();
    if (!rutaImg.empty()) {
        texImagenPlatillo = IMG_LoadTexture(renderer, rutaImg.c_str());
    }
    if (!texImagenPlatillo) {
        std::string defaultPath = RutasAssets::obtenerRutaImagenPlatillo(recetaAMostrar.obtenerCategoria(), "default");
        texImagenPlatillo = IMG_LoadTexture(renderer, defaultPath.c_str());
    }
    
    if (texImagenPlatillo) {
        rectImagenPlatillo = { (float)w - 350.0f, 100.0f, 300.0f, 300.0f }; 
    }

    btnVolver = new Boton(renderer, RutasAssets::obtenerRutaIconoBotonVolver(), 50, h - 80, 60, 60);
}

// [CORREGIDO] Cleanup seguro: Asignar nullptr para evitar doble free
void PantallaDetalleReceta::cleanup() {
    if (texTitulo) { SDL_DestroyTexture(texTitulo); texTitulo = nullptr; }
    if (texImagenPlatillo) { SDL_DestroyTexture(texImagenPlatillo); texImagenPlatillo = nullptr; }
    
    if (fuenteTitulo) { TTF_CloseFont(fuenteTitulo); fuenteTitulo = nullptr; }
    if (fuenteSubtitulo) { TTF_CloseFont(fuenteSubtitulo); fuenteSubtitulo = nullptr; }
    if (fuenteTexto) { TTF_CloseFont(fuenteTexto); fuenteTexto = nullptr; }
    
    if (btnVolver) { delete btnVolver; btnVolver = nullptr; }
}

void PantallaDetalleReceta::handleEvents(Game& game) {
    SDL_Event evento;
    while (SDL_PollEvent(&evento)) {
        if (evento.type == SDL_EVENT_QUIT) game.setEstaCorriendo(false);

        if (evento.type == SDL_EVENT_MOUSE_BUTTON_DOWN && evento.button.button == SDL_BUTTON_LEFT) {
            float mx = evento.button.x;
            float my = evento.button.y;
            if (btnVolver && btnVolver->estaPresionado(mx, my)) {
                game.popEstado();
            }
            
            if (texImagenPlatillo && 
                mx >= rectImagenPlatillo.x && mx <= rectImagenPlatillo.x + rectImagenPlatillo.w &&
                my >= rectImagenPlatillo.y && my <= rectImagenPlatillo.y + rectImagenPlatillo.h) {
                
                std::string ruta = recetaAMostrar.obtenerRutaImagen();
                if (ruta.empty()) ruta = RutasAssets::obtenerRutaImagenPlatillo(recetaAMostrar.obtenerCategoria(), "default");
                game.pushEstado(new PantallaImagenCompleta(ruta));
            }
        }
    }
}

void PantallaDetalleReceta::update(Game& game) {
    (void)game;
    if (btnVolver) btnVolver->actualizar();
}

void PantallaDetalleReceta::render(Game& game) {
    SDL_Renderer* renderer = game.getRenderer();
    int w, h;
    SDL_GetRenderOutputSize(renderer, &w, &h);

    SDL_SetRenderDrawColor(renderer, 250, 248, 240, 255); 
    SDL_FRect bg = {0,0,1024,768};
    SDL_RenderFillRect(renderer, &bg);

    if (texTitulo) SDL_RenderTexture(renderer, texTitulo, nullptr, &rectTitulo);

    renderizarInfoGeneral(renderer, w);
    renderizarIngredientes(renderer, w);
    renderizarProcedimiento(renderer, w, h);

    if (texImagenPlatillo) {
        SDL_RenderTexture(renderer, texImagenPlatillo, nullptr, &rectImagenPlatillo);
        SDL_SetRenderDrawColor(renderer, 200, 200, 200, 255);
        SDL_RenderRect(renderer, &rectImagenPlatillo);
    }

    if (btnVolver) btnVolver->render(renderer);
}

void PantallaDetalleReceta::renderizarInfoGeneral(SDL_Renderer* renderer, int w) {
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    SDL_FRect card = {50, 80, (float)w-420, 60}; 
    SDL_RenderFillRect(renderer, &card);

    std::string info = "Autor: " + recetaAMostrar.obtenerAutor().obtenerNombreCompleto() + 
                       "  |  Tiempo: " + std::to_string(recetaAMostrar.obtenerTiempoPreparacion()) + " min" +
                       "  |  Categoria: " + categoriaATexto(recetaAMostrar.obtenerCategoria());
    
    SDL_Surface* s = TTF_RenderText_Blended(fuenteTexto, info.c_str(), 0, {80, 80, 80, 255});
    if (s) {
        SDL_Texture* t = SDL_CreateTextureFromSurface(renderer, s);
        if (t) {
            SDL_FRect r = { card.x + 20, card.y + 15, (float)s->w, (float)s->h };
            SDL_RenderTexture(renderer, t, nullptr, &r);
            SDL_DestroyTexture(t);
        }
        SDL_DestroySurface(s);
    }
}

void PantallaDetalleReceta::renderizarIngredientes(SDL_Renderer* renderer, int w) {
    (void)w;
    float yStart = 160.0f;
    
    SDL_Surface* sSub = TTF_RenderText_Blended(fuenteSubtitulo, "INGREDIENTES:", 0, {0, 0, 0, 255});
    if(sSub) {
        SDL_Texture* t = SDL_CreateTextureFromSurface(renderer, sSub);
        SDL_FRect r = { 60, yStart, (float)sSub->w, (float)sSub->h };
        SDL_RenderTexture(renderer, t, nullptr, &r);
        SDL_DestroyTexture(t);
        SDL_DestroySurface(sSub);
    }

    const auto& listaIng = recetaAMostrar.obtenerIngredientesConstante();
    float yIng = yStart + 30.0f;
    
    for (int i = 0; i < listaIng.obtenerCantidadElementos(); ++i) {
        SDL_SetRenderDrawColor(renderer, 100, 100, 100, 255);
        SDL_FRect bullet = { 60.0f, yIng + 8, 5, 5 };
        SDL_RenderFillRect(renderer, &bullet);
        
        try {
            const Ingrediente& ing = listaIng.obtenerEnPosicion(i);
            std::string textoIng = ing.obtenerNombre() + " (" + ing.obtenerCantidad() + " " + ing.obtenerUnidad() + ")";
            
            SDL_Surface* sIng = TTF_RenderText_Blended(fuenteTexto, textoIng.c_str(), 0, {60, 60, 60, 255});
            if (sIng) {
                SDL_Texture* tIng = SDL_CreateTextureFromSurface(renderer, sIng);
                SDL_FRect rIng = { 75.0f, yIng, (float)sIng->w, (float)sIng->h };
                SDL_RenderTexture(renderer, tIng, nullptr, &rIng);
                SDL_DestroyTexture(tIng);
                SDL_DestroySurface(sIng);
            }
        } catch (...) {}

        yIng += 25.0f;
    }
}

void PantallaDetalleReceta::renderizarProcedimiento(SDL_Renderer* renderer, int w, int h) {
    float yStart = 400.0f;
    
    SDL_Surface* sSub = TTF_RenderText_Blended(fuenteSubtitulo, "PROCEDIMIENTO:", 0, {0, 0, 0, 255});
    if(sSub) {
        SDL_Texture* t = SDL_CreateTextureFromSurface(renderer, sSub);
        SDL_FRect r = { 50.0f, yStart, (float)sSub->w, (float)sSub->h };
        SDL_RenderTexture(renderer, t, nullptr, &r);
        SDL_DestroyTexture(t);
        SDL_DestroySurface(sSub);
    }

    SDL_Surface* sup = TTF_RenderText_Blended_Wrapped(fuenteTexto, recetaAMostrar.obtenerProcedimiento().c_str(), 0, {60, 60, 60, 255}, w - 100);
    if (sup) {
        SDL_Texture* tProc = SDL_CreateTextureFromSurface(renderer, sup);
        if (tProc) {
            SDL_FRect r = { 50.0f, yStart + 30.0f, (float)sup->w, (float)sup->h };
            if (r.h > (h - yStart - 100)) r.h = h - yStart - 100;
            SDL_RenderTexture(renderer, tProc, nullptr, &r);
            SDL_DestroyTexture(tProc);
        }
        SDL_DestroySurface(sup);
    }
}





===== C:\Universidad\estructuras-de-datos\src\ui\PantallaEliminarReceta.cpp =====
#include "ui/PantallaEliminarReceta.hpp"
#include "ui/PantallaMenuPrincipal.hpp"
#include "Game.hpp"
#include "datastructures/managers/ManejadorRecetas.hpp"
#include "persistence/RutasAssets.hpp"
#include "utils/RenderizadorTextos.hpp"
#include <iostream>
#include <cmath>

PantallaEliminarReceta::PantallaEliminarReceta()
    : fuenteTitulo(nullptr), fuenteInputs(nullptr),
      texturaTitulo(nullptr),
      inputNombre(nullptr), 
      btnEliminar(nullptr), btnCancelar(nullptr) {}

PantallaEliminarReceta::~PantallaEliminarReceta() {
    cleanup();
}

void PantallaEliminarReceta::init(Game& game) {
    SDL_Renderer* renderer = game.getRenderer();
    SDL_Window* window = game.getWindow();
    int w, h;
    SDL_GetRenderOutputSize(renderer, &w, &h);

    fuenteTitulo = TTF_OpenFont(RutasAssets::obtenerRutaFuenteNegrita().c_str(), 32);
    fuenteInputs = TTF_OpenFont(RutasAssets::obtenerRutaFuenteRegular().c_str(), 24);

    SDL_Color colorTitulo = {50, 50, 50, 255};
    texturaTitulo = RenderizadorTextos::renderizarTexto(renderer, fuenteTitulo, "ELIMINAR RECETA", colorTitulo);
    if (texturaTitulo) {
        rectTitulo = { (w - (float)texturaTitulo->w)/2.0f, 50.0f, (float)texturaTitulo->w, (float)texturaTitulo->h };
    }

    float inputW = 400.0f;
    inputNombre = new CajaDeTexto(window, (w - inputW)/2.0f, 200.0f, inputW, 40.0f, fuenteInputs);
    inputNombre->establecerPlaceholder("Nombre exacto a eliminar");

    float btnY = 400.0f;
    btnEliminar = new Boton(renderer, RutasAssets::obtenerRutaIconoBotonEliminar(), w/2.0f - 100.0f, btnY, 80.0f, 80.0f);
    btnCancelar = new Boton(renderer, RutasAssets::obtenerRutaIconoBotonVolver(), w/2.0f + 20.0f, btnY, 80.0f, 80.0f);
}

void PantallaEliminarReceta::cleanup() {
    if (texturaTitulo) { SDL_DestroyTexture(texturaTitulo); texturaTitulo = nullptr; }
    if (fuenteTitulo) { TTF_CloseFont(fuenteTitulo); fuenteTitulo = nullptr; }
    if (fuenteInputs) { TTF_CloseFont(fuenteInputs); fuenteInputs = nullptr; }

    if (inputNombre) { delete inputNombre; inputNombre = nullptr; }
    if (btnEliminar) { delete btnEliminar; btnEliminar = nullptr; }
    if (btnCancelar) { delete btnCancelar; btnCancelar = nullptr; }
}

void PantallaEliminarReceta::handleEvents(Game& game) {
    SDL_Event evento;
    while (SDL_PollEvent(&evento)) {
        if (evento.type == SDL_EVENT_QUIT) {
            game.setEstaCorriendo(false);
        }

        if (inputNombre) inputNombre->manejarEvento(evento);

        if (evento.type == SDL_EVENT_MOUSE_BUTTON_DOWN) {
            if (evento.button.button == SDL_BUTTON_LEFT) {
                float mx = evento.button.x;
                float my = evento.button.y;

                if (btnCancelar && btnCancelar->estaPresionado(mx, my)) {
                    game.popEstado();
                }
                else if (btnEliminar && btnEliminar->estaPresionado(mx, my)) {
                    eliminarReceta(game);
                }
            }
        }
    }
}

void PantallaEliminarReceta::update(Game& game) {
    (void)game;
    if (btnEliminar) btnEliminar->actualizar();
    if (btnCancelar) btnCancelar->actualizar();
}

void PantallaEliminarReceta::render(Game& game) {
    SDL_Renderer* renderer = game.getRenderer();
    int w, h;
    SDL_GetRenderOutputSize(renderer, &w, &h);
    
    // --- FONDO SALMON PASTEL CON PULSO ---
    float tiempo = SDL_GetTicks() / 500.0f;
    Uint8 redIntensity = 245 + (Uint8)(std::sin(tiempo) * 10); // Pulso suave rojizo
    
    SDL_SetRenderDrawColor(renderer, redIntensity, 220, 220, 255);
    SDL_FRect bg = {0, 0, (float)w, (float)h};
    SDL_RenderFillRect(renderer, &bg);

    if (texturaTitulo) SDL_RenderTexture(renderer, texturaTitulo, nullptr, &rectTitulo);
    
    if (inputNombre) inputNombre->render(renderer);

    if (btnEliminar) btnEliminar->render(renderer);
    if (btnCancelar) btnCancelar->render(renderer);
}

void PantallaEliminarReceta::eliminarReceta(Game& game) {
    if (!inputNombre) return;
    std::string nombre = inputNombre->obtenerTexto();
    if (nombre.empty()) return;

    try {
        game.getManejadorRecetas().eliminarRecetaPorNombre(nombre);
        std::cout << "Receta eliminada: " << nombre << std::endl;
        game.popEstado();
    } catch (const std::exception& e) {
        std::cerr << "Error al eliminar: " << e.what() << std::endl;
    }
}


===== C:\Universidad\estructuras-de-datos\src\ui\PantallaGestionArchivos.cpp =====
#include "ui/PantallaGestionArchivos.hpp"
#include "ui/PantallaVisualizarRecetas.hpp"
#include "Game.hpp"
#include "persistence/RutasAssets.hpp"
#include "utils/RenderizadorTextos.hpp"
#include "DatosPruebaRecetario.hpp"
#include <iostream>
#include <filesystem>
#include <limits>

namespace fs = std::filesystem;

PantallaGestionArchivos::PantallaGestionArchivos(bool esModoGuardar)
    : fuenteTitulo(nullptr), fuenteLista(nullptr), texTitulo(nullptr),
      modoGuardar(esModoGuardar), btnNuevoArchivo(nullptr), 
      inputNuevoArchivo(nullptr), btnCargarTest(nullptr), btnVolver(nullptr) {}

PantallaGestionArchivos::~PantallaGestionArchivos() {
    cleanup();
}

void PantallaGestionArchivos::init(Game& game) {
    SDL_Renderer* renderer = game.getRenderer();
    SDL_Window* window = game.getWindow();
    int w, h;
    SDL_GetRenderOutputSize(renderer, &w, &h);

    fuenteTitulo = TTF_OpenFont(RutasAssets::obtenerRutaFuenteNegrita().c_str(), 36);
    fuenteLista = TTF_OpenFont(RutasAssets::obtenerRutaFuenteRegular().c_str(), 20);

    std::string titulo = modoGuardar ? "GUARDAR ARCHIVO" : "CARGAR ARCHIVO";
    texTitulo = RenderizadorTextos::renderizarTexto(renderer, fuenteTitulo, titulo, {50, 50, 70, 255});
    if (texTitulo) {
        rectTitulo = { (w - (float)texTitulo->w)/2.0f, 30.0f, (float)texTitulo->w, (float)texTitulo->h };
    }

    escanearDirectorio(renderer);

    float yBottom = h - 100.0f;
    
    if (modoGuardar) {
        inputNuevoArchivo = new CajaDeTexto(window, w/2 - 200, yBottom, 300, 40, fuenteLista);
        inputNuevoArchivo->establecerPlaceholder("Nombre nuevo archivo...");
        btnNuevoArchivo = new Boton(renderer, "assets/images/icons/archivo_nuevo.png", w/2 + 120, yBottom, 40, 40);
    } else {
        btnCargarTest = new Boton(renderer, "assets/images/icons/archivo_test.png", w/2 - 25, yBottom, 50, 50); 
    }

    btnVolver = new Boton(renderer, RutasAssets::obtenerRutaIconoBotonVolver(), 50, yBottom, 50, 50);
}

void PantallaGestionArchivos::escanearDirectorio(SDL_Renderer* renderer) {
    for(auto& b : listaBotonesArchivos) {
        if (b.btn) delete b.btn;
        if (b.label) SDL_DestroyTexture(b.label);
    }
    listaBotonesArchivos.clear();

    std::string pathSaves = "assets/saves";
    if (!fs::exists(pathSaves)) fs::create_directories(pathSaves);

    float yPos = 100.0f;
    int w, h;
    SDL_GetRenderOutputSize(renderer, &w, &h);

    int fileCount = 0;
    for (const auto& entry : fs::directory_iterator(pathSaves)) {
        if (entry.path().extension() == ".dat") {
            if (fileCount >= 3) continue; // Límite de 3 archivos

            std::string filename = entry.path().filename().string();
            
            BotonArchivo item;
            item.btn = new Boton(renderer, "assets/images/icons/boton_guardar.png", w/2 - 200, yPos, 40, 40);
            item.nombreArchivo = filename;
            
            item.label = RenderizadorTextos::renderizarTexto(renderer, fuenteLista, filename, {0,0,0,255});
            if (item.label) {
                item.rectLabel = { (float)w/2 - 140, yPos + 10, (float)item.label->w, (float)item.label->h };
            }

            listaBotonesArchivos.push_back(item);
            yPos += 60.0f;
            fileCount++;
        }
    }
}

void PantallaGestionArchivos::cleanup() {
    if (texTitulo) { SDL_DestroyTexture(texTitulo); texTitulo = nullptr; }
    if (fuenteTitulo) { TTF_CloseFont(fuenteTitulo); fuenteTitulo = nullptr; }
    if (fuenteLista) { TTF_CloseFont(fuenteLista); fuenteLista = nullptr; }

    for(auto& b : listaBotonesArchivos) {
        if (b.btn) { delete b.btn; b.btn = nullptr; }
        if (b.label) { SDL_DestroyTexture(b.label); b.label = nullptr; }
    }
    listaBotonesArchivos.clear();

    if (btnNuevoArchivo) { delete btnNuevoArchivo; btnNuevoArchivo = nullptr; }
    if (inputNuevoArchivo) { delete inputNuevoArchivo; inputNuevoArchivo = nullptr; }
    if (btnCargarTest) { delete btnCargarTest; btnCargarTest = nullptr; }
    if (btnVolver) { delete btnVolver; btnVolver = nullptr; }
}

void PantallaGestionArchivos::handleEvents(Game& game) {
    SDL_Event evento;
    while (SDL_PollEvent(&evento)) {
        if (evento.type == SDL_EVENT_QUIT) game.setEstaCorriendo(false);

        if (inputNuevoArchivo) inputNuevoArchivo->manejarEvento(evento);

        if (evento.type == SDL_EVENT_MOUSE_BUTTON_DOWN && evento.button.button == SDL_BUTTON_LEFT) {
            float mx = evento.button.x;
            float my = evento.button.y;

            if (btnVolver && btnVolver->estaPresionado(mx, my)) {
                game.popEstado();
                std::cout << "[FLAG] Gestion Archivos: Volver" << std::endl;
                return;
            }

            for (const auto& item : listaBotonesArchivos) {
                if (item.btn->estaPresionado(mx, my)) {
                    seleccionarArchivo(game, "assets/saves/" + item.nombreArchivo);
                    return; 
                }
            }

            if (modoGuardar && btnNuevoArchivo && btnNuevoArchivo->estaPresionado(mx, my)) {
                crearYSeleccionar(game);
                std::cout << "[FLAG] Gestion Archivos: Crear Nuevo" << std::endl;
            }

            if (!modoGuardar && btnCargarTest && btnCargarTest->estaPresionado(mx, my)) {
                cargarDatosPrueba(game);
                std::cout << "[FLAG] Gestion Archivos: Cargar 1000 Pruebas" << std::endl;
            }
        }
    }
}

void PantallaGestionArchivos::seleccionarArchivo(Game& game, const std::string& ruta) {
    std::cout << "[FLAG] Gestion Archivos: INICIANDO I/O. (Ventana se congelará) Ruta: " << ruta << std::endl;
    
    try {
        if (modoGuardar) {
            game.getManejadorRecetas().guardarRecetasAarchivo(ruta);
            std::cout << "[FLAG] Gestion Archivos: Guardado Exitoso." << std::endl;
        } else {
            game.getManejadorRecetas().cargarRecetasDesdeArchivo(ruta);
            std::cout << "[FLAG] Gestion Archivos: Carga Finalizada." << std::endl;
        }
        
        game.popEstado();
    } catch (const std::exception& e) {
        std::cerr << "[ERROR CRITICO IO] Operacion I/O falló: " << e.what() << std::endl;
    }
}

void PantallaGestionArchivos::crearYSeleccionar(Game& game) {
    std::string nombre = inputNuevoArchivo->obtenerTexto();
    if (nombre.empty()) return;
    
    if (nombre.find(".dat") == std::string::npos) nombre += ".dat";
    seleccionarArchivo(game, "assets/saves/" + nombre);
}

void PantallaGestionArchivos::cargarDatosPrueba(Game& game) {
    std::cout << "[FLAG] Gestion Archivos: Generando 1000 recetas en memoria..." << std::endl;
    ListaDoblementeLigada<Receta> datosTest = DatosPruebaRecetario::obtenerRecetasDeEjemplo();
    
    for (int i = 0; i < datosTest.obtenerCantidadElementos(); ++i) {
        Receta r = datosTest.obtenerEnPosicion(i); 
        try {
            game.getManejadorRecetas().agregarRecetaNueva(r);
        } catch (...) {} 
    }
    std::cout << "[FLAG] Gestion Archivos: Datos de prueba inyectados. Saliendo." << std::endl;
    game.popEstado();
}

void PantallaGestionArchivos::update(Game& game) { 
    (void)game;
    for(auto& b : listaBotonesArchivos) b.btn->actualizar();
    if(btnNuevoArchivo) btnNuevoArchivo->actualizar();
    if(btnCargarTest) btnCargarTest->actualizar();
    if(btnVolver) btnVolver->actualizar();
}

void PantallaGestionArchivos::render(Game& game) {
    SDL_Renderer* r = game.getRenderer();
    int w, h;
    SDL_GetRenderOutputSize(r, &w, &h);
    
    SDL_SetRenderDrawColor(r, 230, 235, 240, 255);
    SDL_RenderClear(r);

    if (texTitulo) SDL_RenderTexture(r, texTitulo, nullptr, &rectTitulo);

    for (const auto& item : listaBotonesArchivos) {
        SDL_SetRenderDrawColor(r, 255, 255, 255, 200);
        SDL_FRect row = { 100.0f, item.rectLabel.y - 5, 824.0f, 40.0f };
        SDL_RenderFillRect(r, &row);

        item.btn->render(r);
        SDL_RenderTexture(r, item.label, nullptr, &item.rectLabel);
    }

    float yBottom = (float)h - 100.0f;

    if (modoGuardar) {
        if (inputNuevoArchivo) inputNuevoArchivo->render(r);
        if (btnNuevoArchivo) btnNuevoArchivo->render(r);
        
        SDL_Surface* sLbl = TTF_RenderText_Blended(fuenteLista, "Crear nuevo archivo:", 0, {100, 100, 100, 255});
        if (sLbl) {
            SDL_Texture* tLbl = SDL_CreateTextureFromSurface(r, sLbl);
            SDL_FRect rLbl = { 200.0f, h - 145.0f, (float)sLbl->w, (float)sLbl->h };
            SDL_RenderTexture(r, tLbl, nullptr, &rLbl);
            SDL_DestroyTexture(tLbl);
            SDL_DestroySurface(sLbl);
        }

    } else {
        if (btnCargarTest) {
            btnCargarTest->render(r);
            
            SDL_Surface* sLbl = TTF_RenderText_Blended(fuenteLista, "Cargar datos de prueba", 0, {0, 100, 0, 255});
            if (sLbl) {
                SDL_Texture* tLbl = SDL_CreateTextureFromSurface(r, sLbl);
                SDL_FRect rLbl = { (w/2.0f) + 30.0f, h - 90.0f, (float)sLbl->w, (float)sLbl->h };
                SDL_RenderTexture(r, tLbl, nullptr, &rLbl);
                SDL_DestroyTexture(tLbl);
                SDL_DestroySurface(sLbl);
            }
        }
    }

    if (btnVolver) btnVolver->render(r);
    
    SDL_RenderPresent(r);
}


===== C:\Universidad\estructuras-de-datos\src\ui\PantallaImagenCompleta.cpp =====
#include "ui/PantallaImagenCompleta.hpp"
#include "Game.hpp"
#include <SDL3_image/SDL_image.h>
#include <algorithm>

PantallaImagenCompleta::PantallaImagenCompleta(const std::string& ruta) 
    : rutaImagen(ruta), texturaImagen(nullptr) {}

PantallaImagenCompleta::~PantallaImagenCompleta() {
    cleanup();
}

void PantallaImagenCompleta::init(Game& game) {
    SDL_Renderer* renderer = game.getRenderer();
    int w, h;
    SDL_GetRenderOutputSize(renderer, &w, &h);

    texturaImagen = IMG_LoadTexture(renderer, rutaImagen.c_str());
    if (texturaImagen) {
        float imgW = (float)texturaImagen->w;
        float imgH = (float)texturaImagen->h;
        
        // Ajustar para que quepa en pantalla manteniendo proporcion (Aspect Fit)
        float scale = std::min((float)w / imgW, (float)h / imgH);
        float finalW = imgW * scale;
        float finalH = imgH * scale;

        rectImagen.x = (w - finalW) / 2.0f;
        rectImagen.y = (h - finalH) / 2.0f;
        rectImagen.w = finalW;
        rectImagen.h = finalH;
    }
}

void PantallaImagenCompleta::cleanup() {
    if (texturaImagen) { SDL_DestroyTexture(texturaImagen); texturaImagen = nullptr; }
}

void PantallaImagenCompleta::handleEvents(Game& game) {
    SDL_Event evento;
    while (SDL_PollEvent(&evento)) {
        if (evento.type == SDL_EVENT_QUIT) {
            game.setEstaCorriendo(false);
        }
        // Cualquier click o tecla cierra la imagen
        else if (evento.type == SDL_EVENT_MOUSE_BUTTON_DOWN || 
                 evento.type == SDL_EVENT_KEY_DOWN) {
            game.popEstado();
        }
    }
}

void PantallaImagenCompleta::update(Game& game) { (void)game; }

void PantallaImagenCompleta::render(Game& game) {
    SDL_Renderer* r = game.getRenderer();
    
    // Fondo negro semitransparente para dimming
    SDL_SetRenderDrawColor(r, 0, 0, 0, 240);
    SDL_FRect bg = {0,0,10000,10000};
    SDL_RenderFillRect(r, &bg);

    if (texturaImagen) {
        SDL_RenderTexture(r, texturaImagen, nullptr, &rectImagen);
    }
    
    SDL_RenderPresent(r);
}


===== C:\Universidad\estructuras-de-datos\src\ui\PantallaMenuPrincipal.cpp =====
#include "ui/PantallaMenuPrincipal.hpp"
#include "ui/PantallaVisualizarRecetas.hpp"
#include "ui/PantallaAgregarReceta.hpp"
#include "ui/PantallaSalida.hpp" // <--- NUEVO INCLUDE
#include "Game.hpp"
#include "persistence/RutasAssets.hpp"
#include "utils/RenderizadorTextos.hpp"
#include <iostream>
#include <cmath>

PantallaMenuPrincipal::PantallaMenuPrincipal() 
    : fuenteTitulo(nullptr), texturaTitulo(nullptr), 
      btnAgregar(nullptr), btnVer(nullptr), btnSalir(nullptr), btnHerramientas(nullptr) {}

PantallaMenuPrincipal::~PantallaMenuPrincipal() {
    cleanup();
}

void PantallaMenuPrincipal::init(Game& game) {
    SDL_Renderer* renderer = game.getRenderer();
    int ancho, alto;
    SDL_GetRenderOutputSize(renderer, &ancho, &alto);

    fuenteTitulo = TTF_OpenFont(RutasAssets::obtenerRutaFuenteNegrita().c_str(), 48);
    SDL_Color color = { 80, 80, 80, 255 };
    
    texturaTitulo = RenderizadorTextos::renderizarTexto(renderer, fuenteTitulo, "RECETARIO", color);
    
    if (texturaTitulo) {
        rectTitulo.x = (ancho - texturaTitulo->w)/2.0f;
        rectTitulo.y = 100.0f;
        rectTitulo.w = (float)texturaTitulo->w;
        rectTitulo.h = (float)texturaTitulo->h;
    }

    float tam = 120.0f;
    float esp = 50.0f;
    float xCenter = (ancho / 2.0f) - (tam / 2.0f);
    float yStart = 300.0f;

    btnAgregar = new Boton(renderer, RutasAssets::obtenerRutaIconoBotonAgregar(), xCenter - tam - esp, yStart, tam, tam);
    btnVer = new Boton(renderer, RutasAssets::obtenerRutaIconoBotonGuardar(), xCenter, yStart, tam, tam);
    btnSalir = new Boton(renderer, RutasAssets::obtenerRutaIconoBotonEliminar(), xCenter + tam + esp, yStart, tam, tam);
    btnHerramientas = nullptr; 
}

void PantallaMenuPrincipal::cleanup() {
    if (texturaTitulo) { SDL_DestroyTexture(texturaTitulo); texturaTitulo = nullptr; }
    if (fuenteTitulo) { TTF_CloseFont(fuenteTitulo); fuenteTitulo = nullptr; }
    
    if (btnAgregar) { delete btnAgregar; btnAgregar = nullptr; }
    if (btnVer) { delete btnVer; btnVer = nullptr; }
    if (btnSalir) { delete btnSalir; btnSalir = nullptr; }
}

void PantallaMenuPrincipal::handleEvents(Game& game) {
    SDL_Event evento;
    while (SDL_PollEvent(&evento)) {
        if (evento.type == SDL_EVENT_QUIT) {
            game.setEstaCorriendo(false);
        }
        else if (evento.type == SDL_EVENT_MOUSE_BUTTON_DOWN) {
            if (evento.button.button == SDL_BUTTON_LEFT) {
                float mx = evento.button.x;
                float my = evento.button.y;

                if (btnSalir && btnSalir->estaPresionado(mx, my)) {
                    // CAMBIO: Ir a PantallaSalida en lugar de cerrar directo
                    game.cambiarEstado(new PantallaSalida());
                }
                else if (btnVer && btnVer->estaPresionado(mx, my)) {
                    game.pushEstado(new PantallaVisualizarRecetas());
                }
                else if (btnAgregar && btnAgregar->estaPresionado(mx, my)) {
                   game.pushEstado(new PantallaAgregarReceta());
                }
            }
        }
    }
}

void PantallaMenuPrincipal::update(Game& game) {
    (void)game;
    if (btnAgregar) btnAgregar->actualizar();
    if (btnVer) btnVer->actualizar();
    if (btnSalir) btnSalir->actualizar();

    float tiempo = SDL_GetTicks() / 1000.0f;
    float desplazamiento = std::sin(tiempo * 2.0f) * 10.0f;
    rectTitulo.y = 100.0f + desplazamiento;
}

void PantallaMenuPrincipal::render(Game& game) {
    SDL_Renderer* r = game.getRenderer();
    int w, h;
    SDL_GetRenderOutputSize(r, &w, &h);
    
    // Fondo Rosa Pastel (Mantenemos el diseño anterior)
    SDL_SetRenderDrawColor(r, 255, 228, 235, 255);
    SDL_FRect bg = {0, 0, (float)w, (float)h};
    SDL_RenderFillRect(r, &bg);

    SDL_SetRenderDrawBlendMode(r, SDL_BLENDMODE_BLEND);
    SDL_SetRenderDrawColor(r, 255, 182, 193, 100);

    float tiempo = SDL_GetTicks() / 50.0f;
    float offset = fmod(tiempo, 100.0f);
    
    for (float i = -100; i < w + h; i += 100) {
        SDL_FRect stripe = { i + offset, 0, 40, (float)h };
        SDL_RenderFillRect(r, &stripe); 
    }
    SDL_SetRenderDrawBlendMode(r, SDL_BLENDMODE_NONE);

    if (texturaTitulo) SDL_RenderTexture(r, texturaTitulo, nullptr, &rectTitulo);
    
    if (btnAgregar) btnAgregar->render(r);
    if (btnVer) btnVer->render(r);
    if (btnSalir) btnSalir->render(r);
}


===== C:\Universidad\estructuras-de-datos\src\ui\PantallaOrdenarRecetas.cpp =====


===== C:\Universidad\estructuras-de-datos\src\ui\PantallaSalida.cpp =====
#include "ui/PantallaSalida.hpp"
#include "Game.hpp"
#include "persistence/RutasAssets.hpp"
#include "utils/RenderizadorTextos.hpp"
#include <iostream>
#include <vector>
#include <cmath>

// --- SISTEMA DE PARTÍCULAS (ESTÁTICO PARA ESTA UNIDAD) ---
struct Gota {
    float x, y;
    float w, h;
    float velocidad;
    SDL_Color color;
};

static std::vector<Gota> lluvia;

// Colores pastel para la lluvia
static const std::vector<SDL_Color> paletaPastel = {
    {255, 182, 193, 200}, // Rosa
    {173, 216, 230, 200}, // Azul Claro
    {255, 253, 208, 200}, // Crema
    {152, 251, 152, 200}, // Verde Palido
    {221, 160, 221, 200}  // Ciruela
};

PantallaSalida::PantallaSalida() 
    : fuente(nullptr), textoBase(nullptr), 
      tiempoAcumulado(0.0f), puntos(0), ciclosCompletados(0), ultimoTick(0) {
    
    // Reiniciar lluvia cada vez que entramos
    lluvia.clear();
    for (int i = 0; i < 100; ++i) { // 100 gotas iniciales
        Gota g;
        g.x = (float)(rand() % 1024);
        g.y = (float)(rand() % 768) - 768; // Empezar arriba
        g.w = (float)(rand() % 5 + 2);     // Ancho 2-7px
        g.h = (float)(rand() % 40 + 20);   // Alto 20-60px
        g.velocidad = (float)(rand() % 10 + 5); // Velocidad
        g.color = paletaPastel[rand() % paletaPastel.size()];
        lluvia.push_back(g);
    }
}

PantallaSalida::~PantallaSalida() {
    cleanup();
}

void PantallaSalida::init(Game& game) {
    SDL_Renderer* renderer = game.getRenderer();
    int w, h;
    SDL_GetRenderOutputSize(renderer, &w, &h);

    fuente = TTF_OpenFont(RutasAssets::obtenerRutaFuenteNegrita().c_str(), 48);
    
    textoBase = RenderizadorTextos::renderizarTexto(renderer, fuente, "CERRANDO RECETARIO", {50, 50, 60, 255});
    
    if (textoBase) {
        rectTexto.x = (w - textoBase->w) / 2.0f;
        rectTexto.y = (h - textoBase->h) / 2.0f;
        rectTexto.w = (float)textoBase->w;
        rectTexto.h = (float)textoBase->h;
    }

    ultimoTick = SDL_GetTicks();
    tiempoAcumulado = 0;
    puntos = 0;
    ciclosCompletados = 0;
}

void PantallaSalida::cleanup() {
    if (textoBase) { SDL_DestroyTexture(textoBase); textoBase = nullptr; }
    if (fuente) { TTF_CloseFont(fuente); fuente = nullptr; }
}

void PantallaSalida::handleEvents(Game& game) {
    SDL_Event evento;
    while (SDL_PollEvent(&evento)) {
        if (evento.type == SDL_EVENT_QUIT) {
            game.setEstaCorriendo(false);
        }
    }
}

void PantallaSalida::update(Game& game) {
    Uint64 actual = SDL_GetTicks();
    float dt = (actual - ultimoTick) / 1000.0f; // Delta time en segundos
    // Cap de dt para evitar saltos gigantes si se traba
    if (dt > 0.1f) dt = 0.1f; 
    
    ultimoTick = actual;

    tiempoAcumulado += dt;

    // Actualizar lógica de salida
    static float tiempoPuntos = 0.0f;
    tiempoPuntos += dt;

    if (tiempoPuntos >= 0.5f) {
        tiempoPuntos = 0.0f;
        puntos++;
        if (puntos > 3) {
            puntos = 0;
            ciclosCompletados++;
        }
    }

    if (ciclosCompletados >= 2) {
        game.setEstaCorriendo(false);
    }

    // --- ANIMAR LLUVIA ---
    int w, h;
    SDL_GetRenderOutputSize(game.getRenderer(), &w, &h);

    for (auto& g : lluvia) {
        g.y += g.velocidad * (dt * 60.0f); // Ajuste de velocidad por frame
        
        // Si sale de la pantalla, reciclar arriba
        if (g.y > h) {
            g.y = -(float)(rand() % 200); // Un poco mas arriba
            g.x = (float)(rand() % w);
        }
    }
}

void PantallaSalida::render(Game& game) {
    SDL_Renderer* renderer = game.getRenderer();
    int w, h;
    SDL_GetRenderOutputSize(renderer, &w, &h);

    // Fondo Gris Oscuro Suave (Para que resalten los colores pastel)
    SDL_SetRenderDrawColor(renderer, 40, 40, 45, 255); 
    SDL_FRect bg = {0, 0, (float)w, (float)h};
    SDL_RenderFillRect(renderer, &bg);

    // DIBUJAR LLUVIA
    SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);
    for (const auto& g : lluvia) {
        SDL_SetRenderDrawColor(renderer, g.color.r, g.color.g, g.color.b, g.color.a);
        SDL_FRect rGota = {g.x, g.y, g.w, g.h};
        SDL_RenderFillRect(renderer, &rGota);
    }
    SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_NONE);

    // CAJA CENTRAL (Para que se lea el texto)
    SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 220); // Blanco semitransparente
    SDL_FRect box = { rectTexto.x - 40, rectTexto.y - 20, rectTexto.w + 120, rectTexto.h + 40 };
    SDL_RenderFillRect(renderer, &box);
    SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_NONE);

    // TEXTO
    if (textoBase) {
        SDL_FRect r = rectTexto;
        r.x -= 20.0f; 
        SDL_RenderTexture(renderer, textoBase, nullptr, &r);
    }

    // PUNTOS ANIMADOS
    std::string strPuntos = "";
    for(int i=0; i<puntos; ++i) strPuntos += ".";
    
    if (!strPuntos.empty()) {
        // Color gris oscuro para el texto sobre blanco
        SDL_Texture* tPuntos = RenderizadorTextos::renderizarTexto(renderer, fuente, strPuntos, {50, 50, 60, 255});
        if (tPuntos) {
            SDL_FRect rP = {
                rectTexto.x + rectTexto.w - 15.0f,
                rectTexto.y,
                (float)tPuntos->w,
                (float)tPuntos->h
            };
            SDL_RenderTexture(renderer, tPuntos, nullptr, &rP);
            SDL_DestroyTexture(tPuntos);
        }
    }
}


===== C:\Universidad\estructuras-de-datos\src\ui\PantallaVisualizarRecetas.cpp =====
#include "ui/PantallaVisualizarRecetas.hpp"
#include "ui/PantallaMenuPrincipal.hpp"
#include "ui/PantallaDetalleReceta.hpp"
#include "ui/PantallaEliminarReceta.hpp"
#include "ui/PantallaAgregarReceta.hpp"
#include "ui/PantallaGestionArchivos.hpp"
#include "Game.hpp"
#include "persistence/RutasAssets.hpp"
#include "utils/RenderizadorTextos.hpp"
#include <iostream>
#include <cmath>
#include <vector>
#include <SDL3_image/SDL_image.h>

struct Burbuja { float x, y, speed, size; };
static std::vector<Burbuja> burbujas;

PantallaVisualizarRecetas::PantallaVisualizarRecetas() 
    : fuenteTitulo(nullptr), fuenteLista(nullptr), fuenteUI(nullptr),
      texturaTitulo(nullptr), 
      inputBusqueda(nullptr), btnBuscar(nullptr), btnReset(nullptr),
      btnOrdNombre(nullptr), btnOrdTiempo(nullptr), btnOrdCategoria(nullptr), btnOrdAutor(nullptr),
      btnCargar(nullptr), btnGuardar(nullptr), btnEliminarTodo(nullptr),
      texIconoOjo(nullptr), texIconoBasura(nullptr), texIconoEditar(nullptr),
      texLblNombre(nullptr), texLblTiempo(nullptr), texLblCat(nullptr), texLblAut(nullptr),
      texLblCargar(nullptr), texLblGuardar(nullptr), texLblDelAll(nullptr),
      btnVolver(nullptr), filtroNombre("") {
          
    if (burbujas.empty()) {
        for(int i=0; i<20; ++i) {
            burbujas.push_back({(float)(rand()%1024), (float)(rand()%768), (float)(rand()%2 + 1), (float)(rand()%20 + 10)});
        }
    }
}

PantallaVisualizarRecetas::~PantallaVisualizarRecetas() {
    cleanup();
}

void PantallaVisualizarRecetas::init(Game& game) {
    SDL_Renderer* renderer = game.getRenderer();
    SDL_Window* window = game.getWindow();
    int w, h;
    SDL_GetRenderOutputSize(renderer, &w, &h);

    fuenteTitulo = TTF_OpenFont(RutasAssets::obtenerRutaFuenteNegrita().c_str(), 36);
    fuenteLista = TTF_OpenFont(RutasAssets::obtenerRutaFuenteRegular().c_str(), 20);
    fuenteUI = TTF_OpenFont(RutasAssets::obtenerRutaFuenteRegular().c_str(), 14);

    SDL_Color colorNegro = {0, 0, 0, 255};
    texturaTitulo = RenderizadorTextos::renderizarTexto(renderer, fuenteTitulo, "GESTION DE RECETAS", colorNegro);
    if (texturaTitulo) rectTitulo = { (w - (float)texturaTitulo->w) / 2.0f, 20.0f, (float)texturaTitulo->w, (float)texturaTitulo->h };

    texIconoOjo = IMG_LoadTexture(renderer, "assets/images/icons/boton_ojo.png");
    texIconoBasura = IMG_LoadTexture(renderer, "assets/images/icons/boton_papelera_small.png");
    texIconoEditar = IMG_LoadTexture(renderer, "assets/images/icons/boton_editar.png");

    float searchY = 80.0f;
    inputBusqueda = new CajaDeTexto(window, 50, searchY, 300, 40, fuenteLista);
    inputBusqueda->establecerPlaceholder("Buscar por nombre...");
    btnBuscar = new Boton(renderer, "assets/images/icons/boton_lupa.png", 360, searchY, 40, 40);
    btnReset = new Boton(renderer, RutasAssets::obtenerRutaIconoBotonVolver(), 410, searchY, 40, 40);

    // Filtros
    float sortY = 80.0f;
    float startSortX = 500.0f; float gap = 50.0f;
    btnOrdNombre = new Boton(renderer, "assets/images/icons/filtro_nombre.png", startSortX, sortY, 40, 40);
    texLblNombre = RenderizadorTextos::renderizarTexto(renderer, fuenteUI, "Nombre", colorNegro);
    if(texLblNombre) rLblNombre = {startSortX, sortY+42, (float)texLblNombre->w, (float)texLblNombre->h};

    btnOrdTiempo = new Boton(renderer, "assets/images/icons/filtro_tiempo.png", startSortX + gap, sortY, 40, 40);
    texLblTiempo = RenderizadorTextos::renderizarTexto(renderer, fuenteUI, "Tiempo", colorNegro);
    if(texLblTiempo) rLblTiempo = {startSortX + gap, sortY+42, (float)texLblTiempo->w, (float)texLblTiempo->h};

    btnOrdCategoria = new Boton(renderer, "assets/images/icons/filtro_categoria.png", startSortX + gap*2, sortY, 40, 40);
    texLblCat = RenderizadorTextos::renderizarTexto(renderer, fuenteUI, "Categ.", colorNegro);
    if(texLblCat) rLblCat = {startSortX + gap*2, sortY+42, (float)texLblCat->w, (float)texLblCat->h};

    btnOrdAutor = new Boton(renderer, "assets/images/icons/filtro_autor.png", startSortX + gap*3, sortY, 40, 40);
    texLblAut = RenderizadorTextos::renderizarTexto(renderer, fuenteUI, "Autor", colorNegro);
    if(texLblAut) rLblAut = {startSortX + gap*3, sortY+42, (float)texLblAut->w, (float)texLblAut->h};

    // Gestión
    float dataX = 800.0f; float dataY = 80.0f; float dataGap = 50.0f;
    btnCargar = new Boton(renderer, "assets/images/icons/archivo_cargar.png", dataX, dataY, 40, 40);
    texLblCargar = RenderizadorTextos::renderizarTexto(renderer, fuenteUI, "Cargar", {0,100,0,255});
    if(texLblCargar) rLblCargar = {dataX, dataY+42, (float)texLblCargar->w, (float)texLblCargar->h};

    btnGuardar = new Boton(renderer, "assets/images/icons/boton_guardar.png", dataX + dataGap, dataY, 40, 40);
    texLblGuardar = RenderizadorTextos::renderizarTexto(renderer, fuenteUI, "Guardar", {0,0,200,255});
    if(texLblGuardar) rLblGuardar = {dataX + dataGap, dataY+42, (float)texLblGuardar->w, (float)texLblGuardar->h};

    btnEliminarTodo = new Boton(renderer, RutasAssets::obtenerRutaIconoBotonEliminar(), dataX + dataGap*2, dataY, 40, 40);
    texLblDelAll = RenderizadorTextos::renderizarTexto(renderer, fuenteUI, "Borrar Todo", {200,0,0,255});
    if(texLblDelAll) rLblDelAll = {dataX + dataGap*2, dataY+42, (float)texLblDelAll->w, (float)texLblDelAll->h};

    btnVolver = new Boton(renderer, RutasAssets::obtenerRutaIconoBotonVolver(), 50, h - 80, 60, 60);

    generarCacheListado(game);
}

void PantallaVisualizarRecetas::cleanup() {
    if (texturaTitulo) { SDL_DestroyTexture(texturaTitulo); texturaTitulo = nullptr; }
    if (texIconoOjo) { SDL_DestroyTexture(texIconoOjo); texIconoOjo = nullptr; }
    if (texIconoBasura) { SDL_DestroyTexture(texIconoBasura); texIconoBasura = nullptr; }
    if (texIconoEditar) { SDL_DestroyTexture(texIconoEditar); texIconoEditar = nullptr; }
    
    if (texLblNombre) { SDL_DestroyTexture(texLblNombre); texLblNombre = nullptr; }
    if (texLblTiempo) { SDL_DestroyTexture(texLblTiempo); texLblTiempo = nullptr; }
    if (texLblCat) { SDL_DestroyTexture(texLblCat); texLblCat = nullptr; }
    if (texLblAut) { SDL_DestroyTexture(texLblAut); texLblAut = nullptr; }
    if (texLblCargar) { SDL_DestroyTexture(texLblCargar); texLblCargar = nullptr; }
    if (texLblGuardar) { SDL_DestroyTexture(texLblGuardar); texLblGuardar = nullptr; }
    if (texLblDelAll) { SDL_DestroyTexture(texLblDelAll); texLblDelAll = nullptr; }

    if (fuenteTitulo) { TTF_CloseFont(fuenteTitulo); fuenteTitulo = nullptr; }
    if (fuenteLista) { TTF_CloseFont(fuenteLista); fuenteLista = nullptr; }
    if (fuenteUI) { TTF_CloseFont(fuenteUI); fuenteUI = nullptr; }

    for (auto& item : itemsLista) {
        if (item.textura) SDL_DestroyTexture(item.textura);
        if (item.texMiniatura) SDL_DestroyTexture(item.texMiniatura);
    }
    itemsLista.clear();

    if(inputBusqueda) { delete inputBusqueda; inputBusqueda = nullptr; }
    if(btnBuscar) { delete btnBuscar; btnBuscar = nullptr; }
    if(btnReset) { delete btnReset; btnReset = nullptr; }
    if(btnOrdNombre) { delete btnOrdNombre; btnOrdNombre = nullptr; }
    if(btnOrdTiempo) { delete btnOrdTiempo; btnOrdTiempo = nullptr; }
    if(btnOrdCategoria) { delete btnOrdCategoria; btnOrdCategoria = nullptr; }
    if(btnOrdAutor) { delete btnOrdAutor; btnOrdAutor = nullptr; }
    if(btnCargar) { delete btnCargar; btnCargar = nullptr; }
    if(btnGuardar) { delete btnGuardar; btnGuardar = nullptr; }
    if(btnEliminarTodo) { delete btnEliminarTodo; btnEliminarTodo = nullptr; }
    if(btnVolver) { delete btnVolver; btnVolver = nullptr; }
}

void PantallaVisualizarRecetas::handleEvents(Game& game) {
    SDL_Event evento;
    while (SDL_PollEvent(&evento)) {
        if (evento.type == SDL_EVENT_QUIT) {
            game.setEstaCorriendo(false);
        }

        if (inputBusqueda) inputBusqueda->manejarEvento(evento);

        if (evento.type == SDL_EVENT_MOUSE_BUTTON_DOWN && evento.button.button == SDL_BUTTON_LEFT) {
            float mx = evento.button.x;
            float my = evento.button.y;

            for (const auto& item : itemsLista) {
                // OJO
                if (mx >= item.rectOjo.x && mx <= (item.rectOjo.x + item.rectOjo.w) &&
                    my >= item.rectOjo.y && my <= (item.rectOjo.y + item.rectOjo.h)) {
                    Receta r = game.getManejadorRecetas().obtenerRecetaEnPosicion(item.indiceOriginal);
                    game.pushEstado(new PantallaDetalleReceta(r));
                    std::cout << "[FLAG] Click: Ver Detalle Receta: " << r.obtenerNombrePlatillo() << std::endl;
                    return;
                }
                // EDITAR
                if (mx >= item.rectEditar.x && mx <= (item.rectEditar.x + item.rectEditar.w) &&
                    my >= item.rectEditar.y && my <= (item.rectEditar.y + item.rectEditar.h)) {
                    Receta r = game.getManejadorRecetas().obtenerRecetaEnPosicion(item.indiceOriginal);
                    game.pushEstado(new PantallaAgregarReceta(r));
                    std::cout << "[FLAG] Click: Editar Receta: " << r.obtenerNombrePlatillo() << std::endl;
                    return;
                }
                // ELIMINAR
                if (mx >= item.rectBasura.x && mx <= (item.rectBasura.x + item.rectBasura.w) &&
                    my >= item.rectBasura.y && my <= (item.rectBasura.y + item.rectBasura.h)) {
                    Receta r = game.getManejadorRecetas().obtenerRecetaEnPosicion(item.indiceOriginal);
                    game.getManejadorRecetas().eliminarRecetaPorNombre(r.obtenerNombrePlatillo());
                    generarCacheListado(game); 
                    std::cout << "[FLAG] Click: Eliminar Rapido Receta: " << r.obtenerNombrePlatillo() << std::endl;
                    return;
                }
            }

            if (btnVolver && btnVolver->estaPresionado(mx, my)) {
                game.popEstado();
                std::cout << "[FLAG] Click: Volver" << std::endl;
            }
            else if (btnOrdNombre && btnOrdNombre->estaPresionado(mx, my)) { game.getManejadorRecetas().ordenarRecetasPorNombre(); generarCacheListado(game); std::cout << "[FLAG] Click: Ordenar por Nombre" << std::endl; }
            else if (btnOrdTiempo && btnOrdTiempo->estaPresionado(mx, my)) { game.getManejadorRecetas().ordenarRecetasPorTiempoPreparacion(); generarCacheListado(game); std::cout << "[FLAG] Click: Ordenar por Tiempo" << std::endl; }
            else if (btnOrdCategoria && btnOrdCategoria->estaPresionado(mx, my)) { game.getManejadorRecetas().ordenarRecetasPorCategoria(); generarCacheListado(game); std::cout << "[FLAG] Click: Ordenar por Categoria" << std::endl; }
            else if (btnOrdAutor && btnOrdAutor->estaPresionado(mx, my)) { game.getManejadorRecetas().ordenarRecetasPorAutor(); generarCacheListado(game); std::cout << "[FLAG] Click: Ordenar por Autor" << std::endl; }
            else if (btnBuscar && btnBuscar->estaPresionado(mx, my)) { filtroNombre = inputBusqueda->obtenerTexto(); generarCacheListado(game); std::cout << "[FLAG] Click: Buscar" << std::endl; }
            else if (btnReset && btnReset->estaPresionado(mx, my)) { filtroNombre = ""; inputBusqueda->establecerTexto(""); generarCacheListado(game); std::cout << "[FLAG] Click: Reset Busqueda" << std::endl; }
            else if (btnCargar && btnCargar->estaPresionado(mx, my)) { 
                game.pushEstado(new PantallaGestionArchivos(false)); 
                std::cout << "[FLAG] Click: Gestion Archivos (Modo Cargar)" << std::endl;
            }
            else if (btnGuardar && btnGuardar->estaPresionado(mx, my)) { 
                game.pushEstado(new PantallaGestionArchivos(true)); 
                std::cout << "[FLAG] Click: Gestion Archivos (Modo Guardar)" << std::endl;
            }
            else if (btnEliminarTodo && btnEliminarTodo->estaPresionado(mx, my)) { 
                game.getManejadorRecetas().eliminarTodasLasRecetas(); 
                generarCacheListado(game); 
                std::cout << "[FLAG] Click: Eliminar Todo" << std::endl;
            }
        }
    }
}

void PantallaVisualizarRecetas::update(Game& game) {
    (void)game;
    if(btnBuscar) btnBuscar->actualizar();
    if(btnReset) btnReset->actualizar();
    if(btnOrdNombre) btnOrdNombre->actualizar();
    if(btnOrdTiempo) btnOrdTiempo->actualizar();
    if(btnOrdCategoria) btnOrdCategoria->actualizar();
    if(btnOrdAutor) btnOrdAutor->actualizar();
    if(btnCargar) btnCargar->actualizar();
    if(btnGuardar) btnGuardar->actualizar();
    if(btnEliminarTodo) btnEliminarTodo->actualizar();
    if(btnVolver) btnVolver->actualizar();

    for(auto& b : burbujas) {
        b.y -= b.speed;
        if(b.y < -50) {
            b.y = 768 + 50;
            b.x = (float)(rand() % 1024);
        }
    }
}

void PantallaVisualizarRecetas::generarCacheListado(Game& game) {
    for (auto& item : itemsLista) {
        if (item.textura) SDL_DestroyTexture(item.textura);
        if (item.texMiniatura) SDL_DestroyTexture(item.texMiniatura);
    }
    itemsLista.clear();

    SDL_Renderer* renderer = game.getRenderer();
    SDL_Color colorTexto = {50, 50, 50, 255};
    float yActual = 160.0f;
    float xPadding = 50.0f;

    ManejadorRecetas& manejador = game.getManejadorRecetas();
    int cantidad = manejador.obtenerCantidadRecetas();
    int itemsMostrados = 0;

    for (int i = 0; i < cantidad; ++i) {
        const Receta& receta = manejador.obtenerRecetaEnPosicion(i);
        
        if (!filtroNombre.empty()) {
            std::string nombreRec = receta.obtenerNombrePlatillo();
            if (nombreRec.find(filtroNombre) == std::string::npos) {
                continue;
            }
        }

        std::string textoFila = std::to_string(itemsMostrados + 1) + ". " + 
                                receta.obtenerNombrePlatillo() + 
                                " | " + categoriaATexto(receta.obtenerCategoria()) +
                                " | " + std::to_string(receta.obtenerTiempoPreparacion()) + "min";

        ItemLista nuevoItem;
        nuevoItem.indiceOriginal = i;
        nuevoItem.textura = RenderizadorTextos::renderizarTexto(renderer, fuenteLista, textoFila, colorTexto);
        
        nuevoItem.texMiniatura = nullptr;
        std::string rutaImg = receta.obtenerRutaImagen();
        if (!rutaImg.empty()) {
            nuevoItem.texMiniatura = IMG_LoadTexture(renderer, rutaImg.c_str());
        }

        if (nuevoItem.textura) {
            nuevoItem.rect.x = xPadding + 40; 
            nuevoItem.rect.y = yActual;
            nuevoItem.rect.w = (float)nuevoItem.textura->w;
            nuevoItem.rect.h = (float)nuevoItem.textura->h;
            
            float btnSize = 30.0f;
            float w = 1024.0f;
            nuevoItem.rectOjo = { w - 150.0f, yActual, btnSize, btnSize };
            nuevoItem.rectEditar = { w - 110.0f, yActual, btnSize, btnSize };
            nuevoItem.rectBasura = { w - 70.0f, yActual, btnSize, btnSize };

            itemsLista.push_back(nuevoItem);
            yActual += 35.0f;
            itemsMostrados++;
        }
    }

    if (itemsMostrados == 0) {
        ItemLista itemVacio;
        itemVacio.textura = RenderizadorTextos::renderizarTexto(renderer, fuenteLista, "No se encontraron recetas.", {150, 0, 0, 255});
        if (itemVacio.textura) {
            itemVacio.rect = { xPadding, yActual, (float)itemVacio.textura->w, (float)itemVacio.textura->h };
            itemsLista.push_back(itemVacio);
        }
    }
}

void PantallaVisualizarRecetas::render(Game& game) {
    SDL_Renderer* renderer = game.getRenderer();
    
    SDL_SetRenderDrawColor(renderer, 220, 255, 235, 255);
    SDL_FRect bg = {0, 0, 1024, 768};
    SDL_RenderFillRect(renderer, &bg);

    SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);
    SDL_SetRenderDrawColor(renderer, 180, 240, 200, 150);
    for(const auto& b : burbujas) {
        SDL_FRect rB = {b.x, b.y, b.size, b.size};
        SDL_RenderFillRect(renderer, &rB);
    }
    SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_NONE);

    if (texturaTitulo) SDL_RenderTexture(renderer, texturaTitulo, nullptr, &rectTitulo);

    if (inputBusqueda) inputBusqueda->render(renderer);
    if (btnBuscar) btnBuscar->render(renderer);
    if (btnReset) btnReset->render(renderer);

    if (btnOrdNombre) btnOrdNombre->render(renderer);
    if (texLblNombre) SDL_RenderTexture(renderer, texLblNombre, nullptr, &rLblNombre);
    if (btnOrdTiempo) btnOrdTiempo->render(renderer);
    if (texLblTiempo) SDL_RenderTexture(renderer, texLblTiempo, nullptr, &rLblTiempo);
    if (btnOrdCategoria) btnOrdCategoria->render(renderer);
    if (texLblCat) SDL_RenderTexture(renderer, texLblCat, nullptr, &rLblCat);
    if (btnOrdAutor) btnOrdAutor->render(renderer);
    if (texLblAut) SDL_RenderTexture(renderer, texLblAut, nullptr, &rLblAut);

    if (btnCargar) btnCargar->render(renderer);
    if (texLblCargar) SDL_RenderTexture(renderer, texLblCargar, nullptr, &rLblCargar);
    if (btnGuardar) btnGuardar->render(renderer);
    if (texLblGuardar) SDL_RenderTexture(renderer, texLblGuardar, nullptr, &rLblGuardar);
    if (btnEliminarTodo) btnEliminarTodo->render(renderer);
    if (texLblDelAll) SDL_RenderTexture(renderer, texLblDelAll, nullptr, &rLblDelAll);

    for (const auto& item : itemsLista) {
        SDL_SetRenderDrawColor(renderer, 255, 255, 255, 150);
        SDL_FRect rowBg = { 40, item.rect.y - 2, 944, 34 };
        SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);
        SDL_RenderFillRect(renderer, &rowBg);
        SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_NONE);

        SDL_FRect rectThumb = { 45, item.rect.y, 30, 30 };
        if (item.texMiniatura) SDL_RenderTexture(renderer, item.texMiniatura, nullptr, &rectThumb);
        else {
            SDL_SetRenderDrawColor(renderer, 200, 200, 200, 255);
            SDL_RenderFillRect(renderer, &rectThumb);
        }

        if (item.textura) SDL_RenderTexture(renderer, item.textura, nullptr, &item.rect);
        
        if (texIconoOjo) SDL_RenderTexture(renderer, texIconoOjo, nullptr, &item.rectOjo);
        else {
            SDL_SetRenderDrawColor(renderer, 0, 0, 255, 255);
            SDL_RenderFillRect(renderer, &item.rectOjo);
        }

        if (texIconoEditar) SDL_RenderTexture(renderer, texIconoEditar, nullptr, &item.rectEditar);
        else {
            SDL_SetRenderDrawColor(renderer, 0, 255, 0, 255);
            SDL_RenderFillRect(renderer, &item.rectEditar);
        }

        if (texIconoBasura) SDL_RenderTexture(renderer, texIconoBasura, nullptr, &item.rectBasura);
        else {
            SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
            SDL_RenderFillRect(renderer, &item.rectBasura);
        }
    }

    if (btnVolver) btnVolver->render(renderer);
}


===== C:\Universidad\estructuras-de-datos\src\utils\ConvertidoresFormatos.cpp =====
#include "utils/ConvertidoresFormatos.hpp"
#include <iomanip>
#include <sstream>
#include <algorithm>

std::string ConvertidoresFormatos::enteroAstring(int numero) {
    return std::to_string(numero);
}

std::string ConvertidoresFormatos::floatAstring(float numero, int decimales) {
    std::stringstream stream;
    stream << std::fixed << std::setprecision(decimales) << numero;
    return stream.str();
}

std::string ConvertidoresFormatos::boolAtexto(bool valor) {
    return valor ? "Si" : "No";
}

int ConvertidoresFormatos::stringAentero(const std::string& texto) {
    try {
        return std::stoi(texto);
    } catch (...) {
        return 0;
    }
}

float ConvertidoresFormatos::stringAfloat(const std::string& texto) {
    try {
        return std::stof(texto);
    } catch (...) {
        return 0.0f;
    }
}

std::string ConvertidoresFormatos::limpiarEspacios(const std::string& texto) {
    std::string resultado = texto;
    // Trim izquierda
    resultado.erase(resultado.begin(), std::find_if(resultado.begin(), resultado.end(), [](unsigned char ch) {
        return !std::isspace(ch);
    }));
    // Trim derecha
    resultado.erase(std::find_if(resultado.rbegin(), resultado.rend(), [](unsigned char ch) {
        return !std::isspace(ch);
    }).base(), resultado.end());
    return resultado;
}

std::string ConvertidoresFormatos::convertirAMayusculas(const std::string& texto) {
    std::string resultado = texto;
    std::transform(resultado.begin(), resultado.end(), resultado.begin(), ::toupper);
    return resultado;
}

std::string ConvertidoresFormatos::padearIzquierda(const std::string& texto, int ancho, char relleno) {
    if (texto.length() >= (size_t)ancho) {
        return texto;
    }
    return std::string(ancho - texto.length(), relleno) + texto;
}

std::string ConvertidoresFormatos::padearDerecha(const std::string& texto, int ancho, char relleno) {
    if (texto.length() >= (size_t)ancho) {
        return texto;
    }
    return texto + std::string(ancho - texto.length(), relleno);
}


===== C:\Universidad\estructuras-de-datos\src\utils\RenderizadorTextos.cpp =====
#include "utils/RenderizadorTextos.hpp"
#include <iostream>

SDL_Texture* RenderizadorTextos::renderizarTexto(SDL_Renderer* renderer, TTF_Font* fuente, const std::string& texto, SDL_Color color) {
    // Validaciones básicas
    if (!renderer) {
        // std::cerr << "[WARN] Renderizador nulo en renderizarTexto" << std::endl;
        return nullptr;
    }
    if (!fuente) {
        // std::cerr << "[WARN] Fuente nula en renderizarTexto para: " << texto << std::endl;
        return nullptr;
    }
    if (texto.empty()) {
        return nullptr;
    }

    // Renderizar superficie (0 = longitud automática hasta null-terminator)
    SDL_Surface* superficie = TTF_RenderText_Blended(fuente, texto.c_str(), 0, color);
    
    if (!superficie) {
        // std::cerr << "[ERROR] Fallo TTF_RenderText: " << SDL_GetError() << std::endl;
        return nullptr;
    }

    // Crear textura desde superficie
    SDL_Texture* textura = SDL_CreateTextureFromSurface(renderer, superficie);
    
    // Liberar superficie temporal
    SDL_DestroySurface(superficie);

    if (!textura) {
        std::cerr << "[ERROR] Fallo SDL_CreateTextureFromSurface: " << SDL_GetError() << std::endl;
    }

    return textura;
}


===== C:\Universidad\estructuras-de-datos\src\utils\ValidadorEntradas.cpp =====
#include "utils/ValidadorEntradas.hpp"

// Inicialización de Regex Estáticos
const std::string ValidadorEntradas::REGEX_EMAIL = R"(^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$)";
const std::string ValidadorEntradas::REGEX_NOMBRE = R"(^[a-zA-ZáéíóúÁÉÍÓÚñÑ\s]+$)";
const std::string ValidadorEntradas::REGEX_NUMERO_ENTERO = R"(^\d+$)";
const std::string ValidadorEntradas::REGEX_NUMERO_DECIMAL = R"(^\d+(\.\d+)?$)";

bool ValidadorEntradas::verificarQueNoEsteVacio(const std::string& entrada) {
    return !entrada.empty() && std::any_of(entrada.begin(), entrada.end(), [](unsigned char c){ return !std::isspace(c); });
}

bool ValidadorEntradas::verificarSiEsNombreValido(const std::string& nombre) {
    if (!verificarQueNoEsteVacio(nombre)) return false;
    return std::regex_match(nombre, std::regex(REGEX_NOMBRE));
}

bool ValidadorEntradas::verificarSiEsNumeroEnteroPositivo(const std::string& entrada) {
    if (entrada.empty()) return false;
    return std::regex_match(entrada, std::regex(REGEX_NUMERO_ENTERO));
}

bool ValidadorEntradas::verificarSiEsNumeroDecimalPositivo(const std::string& entrada) {
    if (entrada.empty()) return false;
    return std::regex_match(entrada, std::regex(REGEX_NUMERO_DECIMAL));
}

bool ValidadorEntradas::verificarSiEstaEnRango(int valor, int minimo, int maximo) {
    return valor >= minimo && valor <= maximo;
}

// CORREGIDO: int -> size_t para coincidir con el header
bool ValidadorEntradas::verificarLongitudString(const std::string& entrada, size_t longitudMinima, size_t longitudMaxima) {
    size_t len = entrada.length();
    return len >= longitudMinima && len <= longitudMaxima;
}

bool ValidadorEntradas::verificarSiEsEmailValido(const std::string& email) {
    return std::regex_match(email, std::regex(REGEX_EMAIL));
}

bool ValidadorEntradas::verificarSiEsRutaArchivoValida(const std::string& ruta) {
    return !ruta.empty(); 
}

std::string ValidadorEntradas::limpiarYnormalizarEntrada(const std::string& entrada) {
    std::string temp = entrada;
    temp.erase(temp.begin(), std::find_if(temp.begin(), temp.end(), [](unsigned char ch) {
        return !std::isspace(ch);
    }));
    temp.erase(std::find_if(temp.rbegin(), temp.rend(), [](unsigned char ch) {
        return !std::isspace(ch);
    }).base(), temp.end());
    return temp;
}

std::string ValidadorEntradas::convertirAminusculas(const std::string& texto) {
    std::string res = texto;
    std::transform(res.begin(), res.end(), res.begin(), ::tolower);
    return res;
}

std::string ValidadorEntradas::convertirAmayusculas(const std::string& texto) {
    std::string res = texto;
    std::transform(res.begin(), res.end(), res.begin(), ::toupper);
    return res;
}

std::string ValidadorEntradas::capitalizarPrimeraLetra(const std::string& texto) {
    if (texto.empty()) return texto;
    std::string res = texto;
    res[0] = std::toupper(res[0]);
    return res;
}

bool ValidadorEntradas::verificarSiEsOpcionMenuValida(const std::string& opcion, const std::string& opcionesValidas) {
    if (opcion.length() != 1) return false;
    return opcionesValidas.find(opcion) != std::string::npos;
}


===== C:\Universidad\estructuras-de-datos\src\DatosPruebaRecetario.cpp =====
#include "DatosPruebaRecetario.hpp"
#include <iostream>

ListaDoblementeLigada<Receta> DatosPruebaRecetario::obtenerRecetasDeEjemplo() {
    ListaDoblementeLigada<Receta> baseRecetas;
    
    // Generar las 12 recetas base para copiar
    baseRecetas.agregarAlFinal(crearChilaquilesVerdes());
    baseRecetas.agregarAlFinal(crearMolePolano());
    baseRecetas.agregarAlFinal(crearPozoleRojo());
    baseRecetas.agregarAlFinal(crearTamalesDeRajas());
    baseRecetas.agregarAlFinal(crearEnchaladasSuizas());
    baseRecetas.agregarAlFinal(crearCarneAsada());
    baseRecetas.agregarAlFinal(crearQuesadillasFlordeCalabazo());
    baseRecetas.agregarAlFinal(crearChilesRellenos());
    baseRecetas.agregarAlFinal(crearCochinitaPibil());
    baseRecetas.agregarAlFinal(crearPastelTresLeches());
    baseRecetas.agregarAlFinal(crearSopaDeTortilla());
    baseRecetas.agregarAlFinal(crearFajitasDePollo());
    
    ListaDoblementeLigada<Receta> recetasFinales;
    int baseCount = baseRecetas.obtenerCantidadElementos();

    // Loop para generar 1000 registros (1000 / 12 ~ 83 ciclos)
    for(int i = 0; i < 84; ++i) { 
        for(int j = 0; j < baseCount; ++j) {
            if (recetasFinales.obtenerCantidadElementos() >= 1000) break;

            // Copiar la receta base
            Receta r = baseRecetas.obtenerEnPosicion(j); 
            
            // Modificar el nombre para que no haya duplicados (Ej: 'Pozole Rojo (84)')
            r.establecerNombrePlatillo(r.obtenerNombrePlatillo() + " (" + std::to_string(i) + ")");
            
            recetasFinales.agregarAlFinal(r);
        }
        if (recetasFinales.obtenerCantidadElementos() >= 1000) break;
    }
    
    std::cout << "[INFO] Generados " << recetasFinales.obtenerCantidadElementos() << " registros de prueba." << std::endl;

    return recetasFinales;
}

// ... (Resto de las funciones crearXyz igual que antes)
Receta DatosPruebaRecetario::crearChilaquilesVerdes() {
    Nombre autorChilaquiles("Maria", "Garcia", "Lopez");
    Receta chilaquiles("Chilaquiles Verdes", autorChilaquiles, Categoria::DESAYUNO, 25,
        "1. Cortar las tortillas en triángulos\n"
        "2. Freír los triángulos en aceite caliente\n"
        "3. Cocer los tomatillos verdes\n"
        "4. Licuar tomatillos con cilantro y chile\n"
        "5. Verter salsa sobre los chilaquiles\n"
        "6. Servir con queso y crema");

    chilaquiles.agregarIngredienteOrdenado(Ingrediente("Aceite vegetal", "3", "cucharadas"));
    chilaquiles.agregarIngredienteOrdenado(Ingrediente("Agua", "1", "taza"));
    chilaquiles.agregarIngredienteOrdenado(Ingrediente("Cebolla blanca", "1/2", "pieza"));
    chilaquiles.agregarIngredienteOrdenado(Ingrediente("Cilantro fresco", "1/2", "taza"));
    chilaquiles.agregarIngredienteOrdenado(Ingrediente("Crema mexicana", "1/2", "taza"));
    chilaquiles.agregarIngredienteOrdenado(Ingrediente("Chile serrano verde", "2", "piezas"));
    chilaquiles.agregarIngredienteOrdenado(Ingrediente("Queso fresco", "200", "gramos"));
    chilaquiles.agregarIngredienteOrdenado(Ingrediente("Sal", "1", "cucharadita"));
    chilaquiles.agregarIngredienteOrdenado(Ingrediente("Tortillas de maíz", "12", "piezas"));
    chilaquiles.agregarIngredienteOrdenado(Ingrediente("Tomatillo verde", "500", "gramos"));
    return chilaquiles;
}
Receta DatosPruebaRecetario::crearMolePolano() {
    Nombre autorMole("Roberto", "Sanchez", "Martinez");
    Receta mole("Mole Poblano", autorMole, Categoria::COMIDA, 120,
        "1. Tostar los chiles\n"
        "2. Remojar chiles en agua caliente\n"
        "3. Tostar especias en comal\n"
        "4. Licuar chiles con especias\n"
        "5. Freír la pasta de mole\n"
        "6. Cocinar el pollo\n"
        "7. Combinar pollo con la salsa\n"
        "8. Servir con arroz y tortillas");

    mole.agregarIngredienteOrdenado(Ingrediente("Ajo", "6", "dientes"));
    mole.agregarIngredienteOrdenado(Ingrediente("Almendra", "1/2", "taza"));
    mole.agregarIngredienteOrdenado(Ingrediente("Anís", "1", "cucharadita"));
    mole.agregarIngredienteOrdenado(Ingrediente("Canela", "1", "rama"));
    mole.agregarIngredienteOrdenado(Ingrediente("Caldo de pollo", "1", "litro"));
    mole.agregarIngredienteOrdenado(Ingrediente("Cebolla", "1", "pieza"));
    mole.agregarIngredienteOrdenado(Ingrediente("Chocolate amargo", "100", "gramos"));
    mole.agregarIngredienteOrdenado(Ingrediente("Clavo", "4", "piezas"));
    mole.agregarIngredienteOrdenado(Ingrediente("Comino", "1/2", "cucharadita"));
    mole.agregarIngredienteOrdenado(Ingrediente("Chile pasilla", "4", "piezas"));
    mole.agregarIngredienteOrdenado(Ingrediente("Jengibre", "1", "cucharadita"));
    mole.agregarIngredienteOrdenado(Ingrediente("Mermelada", "1", "cucharada"));
    mole.agregarIngredienteOrdenado(Ingrediente("Pasita", "1/4", "taza"));
    mole.agregarIngredienteOrdenado(Ingrediente("Pechuga de pollo", "1", "pieza"));
    return mole;
}
Receta DatosPruebaRecetario::crearPozoleRojo() {
    Nombre autorPozole("Carmen", "Ruiz", "Hernandez");
    Receta pozole("Pozole Rojo", autorPozole, Categoria::COMIDA, 90,
        "1. Limpiar el maíz pozolero\n"
        "2. Cocer el maíz en agua con cal\n"
        "3. Enjuagar bien el maíz cocido\n"
        "4. Cocer el cerdo\n"
        "5. Preparar la salsa de chiles\n"
        "6. Combinar maíz y cerdo\n"
        "7. Agregar la salsa roja\n"
        "8. Servir con lechuga, orégano y tostadas");

    pozole.agregarIngredienteOrdenado(Ingrediente("Agua", "3", "litros"));
    pozole.agregarIngredienteOrdenado(Ingrediente("Ajo", "4", "dientes"));
    pozole.agregarIngredienteOrdenado(Ingrediente("Caldo de pollo", "2", "litros"));
    pozole.agregarIngredienteOrdenado(Ingrediente("Cebolla", "1", "pieza"));
    pozole.agregarIngredienteOrdenado(Ingrediente("Chile ancho", "6", "piezas"));
    pozole.agregarIngredienteOrdenado(Ingrediente("Chile guajillo", "4", "piezas"));
    pozole.agregarIngredienteOrdenado(Ingrediente("Espaldilla de cerdo", "800", "gramos"));
    pozole.agregarIngredienteOrdenado(Ingrediente("Lechuga fresca", "1/2", "pieza"));
    pozole.agregarIngredienteOrdenado(Ingrediente("Limón", "2", "piezas"));
    pozole.agregarIngredienteOrdenado(Ingrediente("Maíz pozolero", "1", "kilogramo"));
    pozole.agregarIngredienteOrdenado(Ingrediente("Orégano seco", "1", "cucharada"));
    pozole.agregarIngredienteOrdenado(Ingrediente("Sal", "2", "cucharaditas"));
    pozole.agregarIngredienteOrdenado(Ingrediente("Tostadas", "150", "gramos"));
    return pozole;
}
Receta DatosPruebaRecetario::crearTamalesDeRajas() {
    Nombre autorTamales("Ana", "Flores", "Cruz");
    Receta tamales("Tamales de Rajas", autorTamales, Categoria::DESAYUNO, 45,
        "1. Preparar la masa de maíz\n"
        "2. Asar y desvenar los chiles poblanos\n"
        "3. Rellenar los chiles con queso\n"
        "4. Preparar hojas de maíz\n"
        "5. Rellenar las hojas con masa y chile\n"
        "6. Cocer al vapor por 45 minutos\n"
        "7. Servir con salsa fresca");
    tamales.agregarIngredienteOrdenado(Ingrediente("Agua", "1.5", "tazas"));
    tamales.agregarIngredienteOrdenado(Ingrediente("Ajo", "2", "dientes"));
    tamales.agregarIngredienteOrdenado(Ingrediente("Caldo de pollo", "2", "tazas"));
    tamales.agregarIngredienteOrdenado(Ingrediente("Cebolla", "1/2", "pieza"));
    tamales.agregarIngredienteOrdenado(Ingrediente("Chile poblano", "8", "piezas"));
    tamales.agregarIngredienteOrdenado(Ingrediente("Crema", "1/2", "taza"));
    tamales.agregarIngredienteOrdenado(Ingrediente("Harina de maíz", "500", "gramos"));
    tamales.agregarIngredienteOrdenado(Ingrediente("Hojas de maíz secas", "50", "piezas"));
    tamales.agregarIngredienteOrdenado(Ingrediente("Mantequilla", "200", "gramos"));
    tamales.agregarIngredienteOrdenado(Ingrediente("Polvo de hornear", "1", "cucharadita"));
    tamales.agregarIngredienteOrdenado(Ingrediente("Queso Oaxaca", "300", "gramos"));
    tamales.agregarIngredienteOrdenado(Ingrediente("Sal", "1", "cucharadita"));
    return tamales;
}
Receta DatosPruebaRecetario::crearEnchaladasSuizas() {
    Nombre autorEnchaladas("Lupita", "Jimenez", "Vega");
    Receta enchaladas("Enchiladas Suizas", autorEnchaladas, Categoria::COMIDA, 60,
        "1. Preparar la salsa verde\n"
        "2. Cocinar el pollo desmenuzado\n"
        "3. Calentar aceite\n"
        "4. Empapar tortillas en salsa\n"
        "5. Rellenar con pollo\n"
        "6. Rodar las tortillas\n"
        "7. Cubrirlas con salsa y queso\n"
        "8. Hornear a 180°C por 20 minutos");

    enchaladas.agregarIngredienteOrdenado(Ingrediente("Aceite", "2", "cucharadas"));
    enchaladas.agregarIngredienteOrdenado(Ingrediente("Agua", "1", "taza"));
    enchaladas.agregarIngredienteOrdenado(Ingrediente("Ajo", "3", "dientes"));
    enchaladas.agregarIngredienteOrdenado(Ingrediente("Caldo de pollo", "1", "taza"));
    enchaladas.agregarIngredienteOrdenado(Ingrediente("Cebolla", "1/2", "pieza"));
    enchaladas.agregarIngredienteOrdenado(Ingrediente("Chile serrano", "3", "piezas"));
    enchaladas.agregarIngredienteOrdenado(Ingrediente("Cilantro", "1/4", "taza"));
    enchaladas.agregarIngredienteOrdenado(Ingrediente("Crema agria", "1", "taza"));
    enchaladas.agregarIngredienteOrdenado(Ingrediente("Pechuga de pollo", "500", "gramos"));
    enchaladas.agregarIngredienteOrdenado(Ingrediente("Queso blanco", "250", "gramos"));
    enchaladas.agregarIngredienteOrdenado(Ingrediente("Sal", "1", "cucharadita"));
    enchaladas.agregarIngredienteOrdenado(Ingrediente("Tomate", "4", "piezas"));
    enchaladas.agregarIngredienteOrdenado(Ingrediente("Tortillas de maíz", "12", "piezas"));
    return enchaladas;
}
Receta DatosPruebaRecetario::crearCarneAsada() {
    Nombre autorCarne("Javier", "Moreno", "Ramirez");
    Receta carneAsada("Carne Asada", autorCarne, Categoria::COMIDA, 30,
        "1. Limpiar la carne de grasa\n"
        "2. Preparar marinada\n"
        "3. Marinar la carne por 4 horas\n"
        "4. Precalentar la parrilla\n"
        "5. Asar la carne 5 minutos cada lado\n"
        "6. Reposar 5 minutos\n"
        "7. Servir con tortillas y salsa");
    carneAsada.agregarIngredienteOrdenado(Ingrediente("Aceite de oliva", "1/4", "taza"));
    carneAsada.agregarIngredienteOrdenado(Ingrediente("Ajo molido", "4", "dientes"));
    carneAsada.agregarIngredienteOrdenado(Ingrediente("Carne de res", "1", "kilogramo"));
    carneAsada.agregarIngredienteOrdenado(Ingrediente("Cilantro", "1/2", "manojo"));
    carneAsada.agregarIngredienteOrdenado(Ingrediente("Comino", "1", "cucharadita"));
    carneAsada.agregarIngredienteOrdenado(Ingrediente("Jalapeño", "2", "piezas"));
    carneAsada.agregarIngredienteOrdenado(Ingrediente("Limón", "3", "piezas"));
    carneAsada.agregarIngredienteOrdenado(Ingrediente("Orégano seco", "1", "cucharada"));
    carneAsada.agregarIngredienteOrdenado(Ingrediente("Pimienta negra", "1", "cucharadita"));
    carneAsada.agregarIngredienteOrdenado(Ingrediente("Sal", "1", "cucharada"));
    return carneAsada;
}
Receta DatosPruebaRecetario::crearQuesadillasFlordeCalabazo() {
    Nombre autorQuesadillas("Erica", "Dominguez", "Perez");
    Receta quesadillas("Quesadillas de Flor de Calabaza", autorQuesadillas, Categoria::DESAYUNO, 20,
        "1. Limpiar las flores de calabaza\n"
        "2. Picar las flores\n"
        "3. Dorar cebolla en aceite\n"
        "4. Agregar las flores\n"
        "5. Cocinar 5 minutos\n"
        "6. Calentar tortillas\n"
        "7. Rellenar con flores y queso\n"
        "8. Doblar y servir con salsa");

    quesadillas.agregarIngredienteOrdenado(Ingrediente("Aceite vegetal", "2", "cucharadas"));
    quesadillas.agregarIngredienteOrdenado(Ingrediente("Cebolla", "1/2", "pieza"));
    quesadillas.agregarIngredienteOrdenado(Ingrediente("Epazote", "4", "hojas"));
    quesadillas.agregarIngredienteOrdenado(Ingrediente("Flor de calabaza", "500", "gramos"));
    quesadillas.agregarIngredienteOrdenado(Ingrediente("Jalapeño", "1", "pieza"));
    quesadillas.agregarIngredienteOrdenado(Ingrediente("Queso Oaxaca", "200", "gramos"));
    quesadillas.agregarIngredienteOrdenado(Ingrediente("Sal", "1", "cucharadita"));
    quesadillas.agregarIngredienteOrdenado(Ingrediente("Tortillas de maíz", "8", "piezas"));
    return quesadillas;
}
Receta DatosPruebaRecetario::crearChilesRellenos() {
    Nombre autorChiles("Patricia", "Gutierrez", "Lopez");
    Receta chiles("Chiles Rellenos", autorChiles, Categoria::COMIDA, 50,
        "1. Asar los chiles\n"
        "2. Devenar los chiles cuidadosamente\n"
        "3. Preparar el relleno\n"
        "4. Rellenar los chiles\n"
        "5. Preparar la salsa de jitomate\n"
        "6. Batir las claras\n"
        "7. Freír los chiles capados\n"
        "8. Servir cubiertos con salsa");
    chiles.agregarIngredienteOrdenado(Ingrediente("Aceite para freír", "500", "mililitros"));
    chiles.agregarIngredienteOrdenado(Ingrediente("Ajo", "2", "dientes"));
    chiles.agregarIngredienteOrdenado(Ingrediente("Caldo de pollo", "1", "taza"));
    chiles.agregarIngredienteOrdenado(Ingrediente("Cebolla", "1/2", "pieza"));
    chiles.agregarIngredienteOrdenado(Ingrediente("Claras de huevo", "6", "piezas"));
    chiles.agregarIngredienteOrdenado(Ingrediente("Harina", "1", "cucharada"));
    chiles.agregarIngredienteOrdenado(Ingrediente("Jitomate", "6", "piezas"));
    chiles.agregarIngredienteOrdenado(Ingrediente("Queso blanco", "300", "gramos"));
    chiles.agregarIngredienteOrdenado(Ingrediente("Sal", "1", "cucharadita"));
    chiles.agregarIngredienteOrdenado(Ingrediente("Yemas de huevo", "6", "piezas"));
    chiles.agregarIngredienteOrdenado(Ingrediente("Chile poblano", "10", "piezas"));
    return chiles;
}
Receta DatosPruebaRecetario::crearCochinitaPibil() {
    Nombre autorCochinita("Ignacio", "Martinez", "Soto");
    Receta cochinita("Cochinita Pibil", autorCochinita, Categoria::COMIDA, 180,
        "1. Asar los achiotes\n"
        "2. Hacer pasta con achiote\n"
        "3. Marinar la carne\n"
        "4. Preparar papel aluminio\n"
        "5. Envolver la carne\n"
        "6. Hornear 3 horas a 160°C\n"
        "7. Desmuzar la carne\n"
        "8. Servir con tortillas y cebolla morada");
    cochinita.agregarIngredienteOrdenado(Ingrediente("Achiote", "3", "cucharadas"));
    cochinita.agregarIngredienteOrdenado(Ingrediente("Agua", "1/2", "taza"));
    cochinita.agregarIngredienteOrdenado(Ingrediente("Ajo", "8", "dientes"));
    cochinita.agregarIngredienteOrdenado(Ingrediente("Canela", "1/2", "cucharadita"));
    cochinita.agregarIngredienteOrdenado(Ingrediente("Cebolla morada", "2", "piezas"));
    cochinita.agregarIngredienteOrdenado(Ingrediente("Clavo", "2", "piezas"));
    cochinita.agregarIngredienteOrdenado(Ingrediente("Comino", "1", "cucharadita"));
    cochinita.agregarIngredienteOrdenado(Ingrediente("Limón agrio", "3", "piezas"));
    cochinita.agregarIngredienteOrdenado(Ingrediente("Orégano", "1", "cucharadita"));
    cochinita.agregarIngredienteOrdenado(Ingrediente("Paleta de cerdo", "2", "kilogramos"));
    cochinita.agregarIngredienteOrdenado(Ingrediente("Pimienta", "1", "cucharadita"));
    cochinita.agregarIngredienteOrdenado(Ingrediente("Sal", "2", "cucharaditas"));
    return cochinita;
}
Receta DatosPruebaRecetario::crearPastelTresLeches() {
    Nombre autorPastel("Valentina", "Solis", "Navarro");
    Receta pastel("Pastel de Tres Leches", autorPastel, Categoria::NAVIDENO, 40,
        "1. Preparar la masa esponjosa\n"
        "2. Hornear la masa 25 minutos\n"
        "3. Enfriar la masa\n"
        "4. Mezclar las tres leches\n"
        "5. Humedecer el pastel con la mezcla\n"
        "6. Preparar la crema batida\n"
        "7. Cubrir el pastel\n"
        "8. Decorar con fresas y refrigerar");
    pastel.agregarIngredienteOrdenado(Ingrediente("Azúcar", "1", "taza"));
    pastel.agregarIngredienteOrdenado(Ingrediente("Claras de huevo", "5", "piezas"));
    pastel.agregarIngredienteOrdenado(Ingrediente("Crema Evaporada", "1", "lata"));
    pastel.agregarIngredienteOrdenado(Ingrediente("Crema Lechera", "1", "lata"));
    pastel.agregarIngredienteOrdenado(Ingrediente("Crema fresca", "1", "taza"));
    pastel.agregarIngredienteOrdenado(Ingrediente("Esencia de vainilla", "1", "cucharadita"));
    pastel.agregarIngredienteOrdenado(Ingrediente("Fresa fresca", "500", "gramos"));
    pastel.agregarIngredienteOrdenado(Ingrediente("Harina de trigo", "1", "taza"));
    pastel.agregarIngredienteOrdenado(Ingrediente("Leche condensada", "1", "lata"));
    pastel.agregarIngredienteOrdenado(Ingrediente("Polvo de hornear", "1", "cucharadita"));
    pastel.agregarIngredienteOrdenado(Ingrediente("Yema de huevo", "5", "piezas"));
    return pastel;
}
Receta DatosPruebaRecetario::crearSopaDeTortilla() {
    Nombre autorSopa("Guadalupe", "Reyes", "Aguirre");
    Receta sopa("Sopa de Tortilla", autorSopa, Categoria::COMIDA, 35,
        "1. Preparar el caldo\n"
        "2. Cocinar jitomates y cebolla\n"
        "3. Licuar jitomates\n"
        "4. Colar la sopa\n"
        "5. Cortar tortillas en tiras\n"
        "6. Freír las tiras de tortilla\n"
        "7. Verter caldo sobre tortillas\n"
        "8. Agregar aguacate, queso y crema");
    sopa.agregarIngredienteOrdenado(Ingrediente("Aguacate", "1", "pieza"));
    sopa.agregarIngredienteOrdenado(Ingrediente("Ajo", "2", "dientes"));
    sopa.agregarIngredienteOrdenado(Ingrediente("Caldo de pollo", "2", "litros"));
    sopa.agregarIngredienteOrdenado(Ingrediente("Cebolla", "1/2", "pieza"));
    sopa.agregarIngredienteOrdenado(Ingrediente("Chile guajillo", "2", "piezas"));
    sopa.agregarIngredienteOrdenado(Ingrediente("Crema mexicana", "1/2", "taza"));
    sopa.agregarIngredienteOrdenado(Ingrediente("Jitomate maduro", "6", "piezas"));
    sopa.agregarIngredienteOrdenado(Ingrediente("Limón", "1", "pieza"));
    sopa.agregarIngredienteOrdenado(Ingrediente("Queso fresco", "150", "gramos"));
    sopa.agregarIngredienteOrdenado(Ingrediente("Sal", "1", "cucharadita"));
    sopa.agregarIngredienteOrdenado(Ingrediente("Tortillas de maíz", "8", "piezas"));
    return sopa;
}
Receta DatosPruebaRecetario::crearFajitasDePollo() {
    Nombre autorFajitas("Fernando", "Castillo", "Romero");
    Receta fajitas("Fajitas de Pollo", autorFajitas, Categoria::COMIDA, 45,
        "1. Limpiar el pollo\n"
        "2. Preparar marinada\n"
        "3. Marinar 2 horas\n"
        "4. Cortar pimientos\n"
        "5. Precalentar parrilla\n"
        "6. Asar pollo 8 minutos\n"
        "7. Asar verduras\n"
        "8. Servir con tortillas calientes");
    fajitas.agregarIngredienteOrdenado(Ingrediente("Aceite de oliva", "3", "cucharadas"));
    fajitas.agregarIngredienteOrdenado(Ingrediente("Ajo", "3", "dientes"));
    fajitas.agregarIngredienteOrdenado(Ingrediente("Cebolla", "2", "piezas"));
    fajitas.agregarIngredienteOrdenado(Ingrediente("Cilantro", "1/4", "manojo"));
    fajitas.agregarIngredienteOrdenado(Ingrediente("Comino", "1", "cucharadita"));
    fajitas.agregarIngredienteOrdenado(Ingrediente("Jalapeño", "2", "piezas"));
    fajitas.agregarIngredienteOrdenado(Ingrediente("Limón", "2", "piezas"));
    fajitas.agregarIngredienteOrdenado(Ingrediente("Orégano", "1", "cucharadita"));
    fajitas.agregarIngredienteOrdenado(Ingrediente("Pimiento rojo", "2", "piezas"));
    fajitas.agregarIngredienteOrdenado(Ingrediente("Pimiento verde", "2", "piezas"));
    fajitas.agregarIngredienteOrdenado(Ingrediente("Pollo pechuga", "1", "kilogramo"));
    fajitas.agregarIngredienteOrdenado(Ingrediente("Sal", "1", "cucharada"));
    fajitas.agregarIngredienteOrdenado(Ingrediente("Tortillas de trigo", "16", "piezas"));
    return fajitas;
}


===== C:\Universidad\estructuras-de-datos\src\Game.cpp =====
#include "Game.hpp"
#include "ui/PantallaMenuPrincipal.hpp"
#include <iostream>
#include <stdexcept>
// #include <SDL3_image/SDL_image.h> // No es necesario explícitamente aquí si no usamos IMG_Init

Game::Game() : ventana(nullptr), renderer(nullptr), estaCorriendo(false) {
    try {
        inicializarSDL();
        
        // Inicio vacío (sin cargar datos automáticos)
        // cargarDatos(); 
        
        this->estaCorriendo = true;
        
        std::cout << "[DEBUG] Creando estado Menu Principal..." << std::endl;
        pushEstado(new PantallaMenuPrincipal()); 
        std::cout << "[SISTEMA] Inicializacion completa." << std::endl;
        
    } catch (const std::exception& e) {
        std::cerr << "Error fatal durante la inicializacion: " << e.what() << std::endl;
        this->estaCorriendo = false;
    }
}

Game::~Game() {
    limpiar();
}

void Game::inicializarSDL() {
    if (!SDL_Init(SDL_INIT_VIDEO)) {
        throw std::runtime_error(std::string("Error al inicializar SDL: ") + SDL_GetError());
    }

    ventana = SDL_CreateWindow("Recetario Interactivo (EDA)", 1024, 768, 0);
    if (!ventana) throw std::runtime_error("Error creando ventana: " + std::string(SDL_GetError()));

    renderer = SDL_CreateRenderer(ventana, NULL);
    if (!renderer) throw std::runtime_error("Error creando renderer: " + std::string(SDL_GetError()));
    
    SDL_SetRenderVSync(renderer, 1);
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);

    if (!TTF_Init()) {
        throw std::runtime_error("Error al inicializar TTF: " + std::string(SDL_GetError()));
    }
    
    // NOTA: En SDL3_image, IMG_Init ya no es necesario/no existe.
    // La librería se auto-inicializa al usar IMG_Load.
    
    std::cout << "[SISTEMA] Subsistemas SDL iniciados." << std::endl;
}

void Game::cargarDatos() {
    try {
        manejadorRecetas.cargarRecetasDesdeArchivo(RUTA_ARCHIVO_RECETAS);
    } catch (...) {
        std::cout << "[DATOS] Error o archivo no encontrado." << std::endl;
    }
}

void Game::limpiar() {
    try {
        // Guardado manual recomendado, pero dejamos el automático por seguridad
        manejadorRecetas.guardarRecetasAarchivo(RUTA_ARCHIVO_RECETAS);
    } catch (const std::exception& e) {
        std::cerr << "Error al guardar recetas: " << e.what() << std::endl;
    }

    while (!estadosJuego.estaVacia()) {
        try {
            GameState* estadoActual = estadosJuego.consultarTope();
            if (estadoActual) {
                estadoActual->cleanup();
                delete estadoActual;
            }
            estadosJuego.desapilar();
        } catch (...) {
             break; 
        }
    }

    if (renderer) { SDL_DestroyRenderer(renderer); renderer = nullptr; }
    if (ventana) { SDL_DestroyWindow(ventana); ventana = nullptr; }
    
    TTF_Quit();
    // IMG_Quit(); // Eliminado por ser obsoleto
    SDL_Quit();
    
    std::cout << "[SISTEMA] Recursos liberados. Adios." << std::endl;
}

void Game::procesarEventos() {
    if (!estadosJuego.estaVacia()) {
        estadosJuego.consultarTope()->handleEvents(*this);
    }
}

void Game::actualizar() {
    if (!estadosJuego.estaVacia()) {
        estadosJuego.consultarTope()->update(*this);
    }
}

void Game::dibujar() {
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    SDL_RenderClear(renderer);

    if (!estadosJuego.estaVacia()) {
        estadosJuego.consultarTope()->render(*this);
    }

    SDL_RenderPresent(renderer);
}

void Game::pushEstado(GameState* estado) {
    if (!estado) return;
    estadosJuego.apilar(estado);
    estadosJuego.consultarTope()->init(*this);
}

void Game::popEstado() {
    if (!estadosJuego.estaVacia()) {
        GameState* estadoAeliminar = estadosJuego.consultarTope();
        if (estadoAeliminar) estadoAeliminar->cleanup();
        estadosJuego.desapilar();
        delete estadoAeliminar;
    }
}

void Game::cambiarEstado(GameState* estadoNuevo) {
    if (!estadoNuevo) return;
    
    GameState* estadoAnterior = nullptr;
    if (!estadosJuego.estaVacia()) {
        estadoAnterior = estadosJuego.consultarTope();
        estadosJuego.desapilar();
    }
    
    if (estadoAnterior) {
        estadoAnterior->cleanup();
        delete estadoAnterior;
    }
    
    estadosJuego.apilar(estadoNuevo);
    estadosJuego.consultarTope()->init(*this);
}

void Game::run() {
    std::cout << "[RUN] Iniciando bucle principal..." << std::endl;
    while (estaCorriendo) {
        if (estadosJuego.estaVacia()) {
            estaCorriendo = false;
            continue;
        }

        procesarEventos();
        actualizar();
        dibujar();
        
        SDL_Delay(16);
    }
    std::cout << "[RUN] Bucle finalizado." << std::endl;
}


===== C:\Universidad\estructuras-de-datos\src\main.cpp =====
#include <SDL3/SDL.h>
#include "Game.hpp"
#include <iostream>

// ðŸ”¥ CORRECCIÃ“N: main estÃ¡ndar para SDL3
int main(int argc, char* argv[]) {
    // Silenciar parÃ¡metros no usados
    (void)argc;
    (void)argv;
    
    try {
        Game recetarioGame;
        if (recetarioGame.estaCorriendoApp()) {
            recetarioGame.run();
        }
    } catch (const std::exception& e) {
        std::cerr << "Error catastrofico: " << e.what() << std::endl;
        return -1;
    } catch (...) {
        std::cerr << "Error desconocido." << std::endl;
        return -1;
    }
    return 0;
}


===== C:\Universidad\estructuras-de-datos\tests\TestListas.cpp =====
#include <iostream>
#include "datastructures/templates/ListaDoblementeLigada.hpp"

int main() {
    ListaDoblementeLigada<int> lista;
    
    // Test bÃ¡sico
    lista.agregarAlFinal(1);
    lista.agregarAlFinal(2);
    lista.agregarAlFinal(3);
    
    std::cout << "Lista doble: " << lista.obtenerCantidadElementos() << " elementos" << std::endl;
    
    return 0;
}


===== C:\Universidad\estructuras-de-datos\tests\TestOrdenamiento.cpp =====


===== C:\Universidad\estructuras-de-datos\tests\TestPilas.cpp =====


